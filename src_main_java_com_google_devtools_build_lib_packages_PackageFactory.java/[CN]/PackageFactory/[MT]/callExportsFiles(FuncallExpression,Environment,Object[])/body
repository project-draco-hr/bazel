{
  Package.LegacyBuilder pkgBuilder=getContext(env,ast).pkgBuilder;
  List<String> files=Type.STRING_LIST.convert(namedArgs[0],"'exports_files' operand");
  RuleVisibility visibility=namedArgs[1] == null ? ConstantRuleVisibility.PUBLIC : getVisibility(Type.LABEL_LIST.convert(namedArgs[1],"'exports_files' operand",pkgBuilder.getBuildFileLabel()));
  License license=namedArgs[2] == null ? null : Type.LICENSE.convert(namedArgs[2],"'exports_files' operand");
  for (  String file : files) {
    String errorMessage=LabelValidator.validateTargetName(file);
    if (errorMessage != null) {
      throw new EvalException(ast.getLocation(),errorMessage);
    }
    try {
      InputFile inputFile=pkgBuilder.createInputFile(file,ast.getLocation());
      if (inputFile.isVisibilitySpecified() && inputFile.getVisibility() != visibility) {
        throw new EvalException(ast.getLocation(),String.format("visibility for exported file '%s' declared twice",inputFile.getName()));
      }
      if (license != null && inputFile.isLicenseSpecified()) {
        throw new EvalException(ast.getLocation(),String.format("licenses for exported file '%s' declared twice",inputFile.getName()));
      }
      if (license == null && pkgBuilder.getDefaultLicense() == License.NO_LICENSE && pkgBuilder.getBuildFileLabel().toString().startsWith("//third_party/")) {
        throw new EvalException(ast.getLocation(),"third-party file '" + inputFile.getName() + "' lacks a license declaration "+ "with one of the following types: notice, reciprocal, permissive, "+ "restricted, unencumbered, by_exception_only");
      }
      pkgBuilder.setVisibilityAndLicense(inputFile,visibility,license);
    }
 catch (    Package.Builder.GeneratedLabelConflict e) {
      throw new EvalException(ast.getLocation(),e.getMessage());
    }
  }
  return Environment.NONE;
}
