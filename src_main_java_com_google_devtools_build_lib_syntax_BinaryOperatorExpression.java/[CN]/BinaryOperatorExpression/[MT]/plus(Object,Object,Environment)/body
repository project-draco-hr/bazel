{
  if (lval instanceof Integer && rval instanceof Integer) {
    return ((Integer)lval).intValue() + ((Integer)rval).intValue();
  }
  if (lval instanceof String && rval instanceof String) {
    return (String)lval + (String)rval;
  }
  if (lval instanceof List<?> && rval instanceof List<?>) {
    List<?> llist=(List<?>)lval;
    List<?> rlist=(List<?>)rval;
    if (EvalUtils.isTuple(llist) != EvalUtils.isTuple(rlist)) {
      throw new EvalException(getLocation(),"can only concatenate " + EvalUtils.getDataTypeName(llist) + " (not \""+ EvalUtils.getDataTypeName(rlist)+ "\") to "+ EvalUtils.getDataTypeName(llist));
    }
    if (llist instanceof GlobList<?> || rlist instanceof GlobList<?>) {
      return GlobList.concat(llist,rlist);
    }
 else {
      List<Object> result=Lists.newArrayListWithCapacity(llist.size() + rlist.size());
      result.addAll(llist);
      result.addAll(rlist);
      return EvalUtils.makeSequence(result,EvalUtils.isTuple(llist));
    }
  }
  if (lval instanceof SelectorValue || rval instanceof SelectorValue || lval instanceof SelectorList|| rval instanceof SelectorList) {
    return SelectorList.concat(getLocation(),lval,rval);
  }
  if ((lval instanceof SkylarkList || lval instanceof List<?>) && ((rval instanceof SkylarkList || rval instanceof List<?>))) {
    SkylarkList left=(SkylarkList)SkylarkType.convertToSkylark(lval,env);
    SkylarkList right=(SkylarkList)SkylarkType.convertToSkylark(rval,env);
    boolean isImmutable=left.isTuple();
    if (isImmutable != right.isTuple()) {
      throw new EvalException(getLocation(),"can only concatenate " + EvalUtils.getDataTypeName(left) + " (not \""+ EvalUtils.getDataTypeName(right)+ "\") to "+ EvalUtils.getDataTypeName(left));
    }
    Iterable<Object> concatenated=Iterables.concat(left,right);
    if (isImmutable) {
      return Tuple.copyOf(concatenated);
    }
 else {
      return new MutableList(concatenated,env);
    }
  }
  if (lval instanceof Map<?,?> && rval instanceof Map<?,?>) {
    Map<?,?> ldict=(Map<?,?>)lval;
    Map<?,?> rdict=(Map<?,?>)rval;
    Map<Object,Object> result=new LinkedHashMap<>(ldict.size() + rdict.size());
    result.putAll(ldict);
    result.putAll(rdict);
    return ImmutableMap.copyOf(result);
  }
  if (lval instanceof SkylarkClassObject && rval instanceof SkylarkClassObject) {
    return SkylarkClassObject.concat((SkylarkClassObject)lval,(SkylarkClassObject)rval,getLocation());
  }
  if (lval instanceof SkylarkNestedSet) {
    return new SkylarkNestedSet((SkylarkNestedSet)lval,rval,getLocation());
  }
  throw new EvalException(getLocation(),String.format("unsupported operand type(s) for %s: '%s' and '%s'",operator,EvalUtils.getDataTypeName(lval),EvalUtils.getDataTypeName(rval)));
}
