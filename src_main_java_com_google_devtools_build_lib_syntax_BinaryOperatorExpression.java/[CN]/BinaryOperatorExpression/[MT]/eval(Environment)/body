{
  Object lval=lhs.eval(env);
  if (operator == Operator.AND) {
    if (EvalUtils.toBoolean(lval)) {
      return rhs.eval(env);
    }
 else {
      return lval;
    }
  }
  if (operator == Operator.OR) {
    if (EvalUtils.toBoolean(lval)) {
      return lval;
    }
 else {
      return rhs.eval(env);
    }
  }
  Object rval=rhs.eval(env);
switch (operator) {
case PLUS:
{
      if (lval instanceof Integer && rval instanceof Integer) {
        return ((Integer)lval).intValue() + ((Integer)rval).intValue();
      }
      if (lval instanceof String && rval instanceof String) {
        return (String)lval + (String)rval;
      }
      if (lval instanceof List<?> && rval instanceof List<?>) {
        List<?> llist=(List<?>)lval;
        List<?> rlist=(List<?>)rval;
        if (EvalUtils.isImmutable(llist) != EvalUtils.isImmutable(rlist)) {
          throw new EvalException(getLocation(),"can only concatenate " + EvalUtils.getDataTypeName(rlist) + " (not \""+ EvalUtils.getDataTypeName(llist)+ "\") to "+ EvalUtils.getDataTypeName(rlist));
        }
        if (llist instanceof GlobList<?> || rlist instanceof GlobList<?>) {
          return GlobList.concat(llist,rlist);
        }
 else {
          List<Object> result=Lists.newArrayListWithCapacity(llist.size() + rlist.size());
          result.addAll(llist);
          result.addAll(rlist);
          return EvalUtils.makeSequence(result,EvalUtils.isImmutable(llist));
        }
      }
      if (lval instanceof SelectorValue || rval instanceof SelectorValue || lval instanceof SelectorList|| rval instanceof SelectorList) {
        return SelectorList.concat(getLocation(),lval,rval);
      }
      if (lval instanceof SkylarkList && rval instanceof SkylarkList) {
        return SkylarkList.concat((SkylarkList)lval,(SkylarkList)rval,getLocation());
      }
      if (lval instanceof Map<?,?> && rval instanceof Map<?,?>) {
        Map<?,?> ldict=(Map<?,?>)lval;
        Map<?,?> rdict=(Map<?,?>)rval;
        Map<Object,Object> result=Maps.newHashMapWithExpectedSize(ldict.size() + rdict.size());
        result.putAll(ldict);
        result.putAll(rdict);
        return ImmutableMap.copyOf(result);
      }
      if (lval instanceof SkylarkClassObject && rval instanceof SkylarkClassObject) {
        return SkylarkClassObject.concat((SkylarkClassObject)lval,(SkylarkClassObject)rval,getLocation());
      }
      if (lval instanceof SkylarkNestedSet) {
        return new SkylarkNestedSet((SkylarkNestedSet)lval,rval,getLocation());
      }
      break;
    }
case MINUS:
{
    if (lval instanceof Integer && rval instanceof Integer) {
      return ((Integer)lval).intValue() - ((Integer)rval).intValue();
    }
    break;
  }
case MULT:
{
  if (lval instanceof Integer && rval instanceof Integer) {
    return ((Integer)lval).intValue() * ((Integer)rval).intValue();
  }
  if (lval instanceof String && rval instanceof Integer) {
    return Strings.repeat((String)lval,((Integer)rval).intValue());
  }
  if (lval instanceof Integer && rval instanceof String) {
    return Strings.repeat((String)rval,((Integer)lval).intValue());
  }
  break;
}
case PERCENT:
{
if (lval instanceof Integer && rval instanceof Integer) {
  if (rval.equals(0)) {
    throw new EvalException(getLocation(),"integer modulo by zero");
  }
  return ((Integer)lval).intValue() % ((Integer)rval).intValue();
}
if (lval instanceof String) {
  try {
    String pattern=(String)lval;
    if (rval instanceof List<?>) {
      List<?> rlist=(List<?>)rval;
      if (EvalUtils.isTuple(rlist)) {
        return EvalUtils.formatString(pattern,rlist);
      }
    }
    if (rval instanceof SkylarkList) {
      SkylarkList rlist=(SkylarkList)rval;
      if (rlist.isTuple()) {
        return EvalUtils.formatString(pattern,rlist.toList());
      }
    }
    return EvalUtils.formatString(pattern,Collections.singletonList(rval));
  }
 catch (  IllegalFormatException e) {
    throw new EvalException(getLocation(),e.getMessage());
  }
}
break;
}
case EQUALS_EQUALS:
{
return lval.equals(rval);
}
case NOT_EQUALS:
{
return !lval.equals(rval);
}
case LESS:
{
return compare(lval,rval) < 0;
}
case LESS_EQUALS:
{
return compare(lval,rval) <= 0;
}
case GREATER:
{
return compare(lval,rval) > 0;
}
case GREATER_EQUALS:
{
return compare(lval,rval) >= 0;
}
case IN:
{
if (rval instanceof SkylarkList) {
for (Object obj : (SkylarkList)rval) {
if (obj.equals(lval)) {
return true;
}
}
return false;
}
 else if (rval instanceof Collection<?>) {
return ((Collection<?>)rval).contains(lval);
}
 else if (rval instanceof Map<?,?>) {
return ((Map<?,?>)rval).containsKey(lval);
}
 else if (rval instanceof SkylarkNestedSet) {
return ((SkylarkNestedSet)rval).expandedSet().contains(lval);
}
 else if (rval instanceof String) {
if (lval instanceof String) {
return ((String)rval).contains((String)lval);
}
 else {
throw new EvalException(getLocation(),"in operator only works on strings if the left operand is also a string");
}
}
 else {
throw new EvalException(getLocation(),"in operator only works on lists, tuples, sets, dicts and strings");
}
}
default :
{
throw new AssertionError("Unsupported binary operator: " + operator);
}
}
throw new EvalException(getLocation(),String.format("unsupported operand type(s) for %s: '%s' and '%s'",operator,EvalUtils.getDataTypeName(lval),EvalUtils.getDataTypeName(rval)));
}
