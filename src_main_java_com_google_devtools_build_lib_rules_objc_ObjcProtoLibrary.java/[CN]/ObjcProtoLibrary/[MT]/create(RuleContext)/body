{
  Artifact compileProtos=ruleContext.getPrerequisiteArtifact(ObjcProtoLibraryRule.COMPILE_PROTOS_ATTR,Mode.HOST);
  Optional<Artifact> optionsFile=Optional.fromNullable(ruleContext.getPrerequisiteArtifact(ObjcProtoLibraryRule.OPTIONS_FILE_ATTR,Mode.HOST));
  NestedSet<Artifact> protos=NestedSetBuilder.<Artifact>stableOrder().addAll(ruleContext.getPrerequisiteArtifacts("deps",Mode.TARGET).filter(FileType.of(".proto")).list()).addTransitive(maybeGetProtoSources(ruleContext)).build();
  if (Iterables.isEmpty(protos)) {
    ruleContext.ruleError(NO_PROTOS_ERROR);
  }
  ImmutableList<Artifact> libProtobuf=ruleContext.getPrerequisiteArtifacts(ObjcProtoLibraryRule.LIBPROTOBUF_ATTR,Mode.TARGET).list();
  ImmutableList<Artifact> protoSupport=ruleContext.getPrerequisiteArtifacts(ObjcProtoLibraryRule.PROTO_SUPPORT_ATTR,Mode.HOST).list();
  String uniqueDirectoryName="_generated_protos";
  PathFragment rootRelativeOutputDir=ruleContext.getUniqueDirectory(uniqueDirectoryName);
  PathFragment workspaceRelativeOutputDir=new PathFragment(ruleContext.getBinOrGenfilesDirectory().getExecPath(),rootRelativeOutputDir);
  PathFragment generatedProtoDir=new PathFragment(workspaceRelativeOutputDir,ruleContext.getLabel().getPackageFragment());
  boolean outputCpp=ruleContext.attributes().get(ObjcProtoLibraryRule.OUTPUT_CPP_ATTR,Type.BOOLEAN);
  boolean useObjcHeaderNames=ruleContext.attributes().get(ObjcProtoLibraryRule.USE_OBJC_HEADER_NAMES_ATTR,Type.BOOLEAN);
  ImmutableList<Artifact> protoGeneratedSources=outputArtifacts(ruleContext,uniqueDirectoryName,protos,FileType.of(".pb." + (outputCpp ? "cc" : "m")),outputCpp);
  ImmutableList<Artifact> protoGeneratedHeaders=outputArtifacts(ruleContext,uniqueDirectoryName,protos,FileType.of(".pb" + (useObjcHeaderNames ? "objc.h" : ".h")),outputCpp);
  Artifact inputFileList=ruleContext.getUniqueDirectoryArtifact("_protos","_proto_input_files",ruleContext.getConfiguration().getGenfilesDirectory());
  ruleContext.registerAction(new FileWriteAction(ruleContext.getActionOwner(),inputFileList,Artifact.joinExecPaths("\n",protos),false));
  CustomCommandLine.Builder commandLineBuilder=new CustomCommandLine.Builder().add(compileProtos.getExecPathString()).add("--input-file-list").add(inputFileList.getExecPathString()).add("--output-dir").add(workspaceRelativeOutputDir.getSafePathString());
  if (optionsFile.isPresent()) {
    commandLineBuilder.add("--compiler-options-path").add(optionsFile.get().getExecPathString());
  }
  if (outputCpp) {
    commandLineBuilder.add("--generate-cpp");
  }
  if (useObjcHeaderNames) {
    commandLineBuilder.add("--use-objc-header-names");
  }
  if (!Iterables.isEmpty(protos)) {
    ruleContext.registerAction(ObjcRuleClasses.spawnOnDarwinActionBuilder(ruleContext).setMnemonic("GenObjcProtos").addInput(compileProtos).addInputs(optionsFile.asSet()).addInputs(protos).addInput(inputFileList).addInputs(libProtobuf).addInputs(protoSupport).addOutputs(Iterables.concat(protoGeneratedSources,protoGeneratedHeaders)).setExecutable(new PathFragment("/usr/bin/python")).setCommandLine(commandLineBuilder.build()).build(ruleContext));
  }
  IntermediateArtifacts intermediateArtifacts=ObjcRuleClasses.intermediateArtifacts(ruleContext);
  CompilationArtifacts compilationArtifacts=new CompilationArtifacts.Builder().addNonArcSrcs(protoGeneratedSources).setIntermediateArtifacts(intermediateArtifacts).setPchFile(Optional.<Artifact>absent()).addAdditionalHdrs(protoGeneratedHeaders).addAdditionalHdrs(protoGeneratedSources).build();
  ImmutableSet.Builder<PathFragment> searchPathEntriesBuilder=new ImmutableSet.Builder<PathFragment>().add(workspaceRelativeOutputDir);
  boolean libPerProtoIncludes=ruleContext.attributes().get(ObjcProtoLibraryRule.PER_PROTO_INCLUDES,Type.BOOLEAN);
  if (ruleContext.getFragment(ObjcConfiguration.class).perProtoIncludes() || libPerProtoIncludes) {
    searchPathEntriesBuilder.add(generatedProtoDir).addAll(Iterables.transform(protoGeneratedHeaders,PARENT_PATHFRAGMENT));
  }
  ImmutableSet<PathFragment> searchPathEntries=searchPathEntriesBuilder.build();
  ObjcCommon common=new ObjcCommon.Builder(ruleContext).setCompilationArtifacts(compilationArtifacts).addUserHeaderSearchPaths(searchPathEntries).addDepObjcProviders(ruleContext.getPrerequisites(ObjcProtoLibraryRule.LIBPROTOBUF_ATTR,Mode.TARGET,ObjcProvider.class)).setIntermediateArtifacts(intermediateArtifacts).build();
  NestedSetBuilder<Artifact> filesToBuild=NestedSetBuilder.<Artifact>stableOrder().addAll(common.getCompiledArchive().asSet()).addAll(protoGeneratedSources).addAll(protoGeneratedHeaders);
  ObjcConfiguration configuration=ObjcRuleClasses.objcConfiguration(ruleContext);
  XcodeProvider.Builder xcodeProviderBuilder=new XcodeProvider.Builder().addUserHeaderSearchPaths(searchPathEntries).addCopts(configuration.getCopts()).addHeaders(protoGeneratedHeaders).setCompilationArtifacts(common.getCompilationArtifacts().get());
  new CompilationSupport(ruleContext).registerCompileAndArchiveActions(common);
  new XcodeSupport(ruleContext).addFilesToBuild(filesToBuild).addXcodeSettings(xcodeProviderBuilder,common.getObjcProvider(),LIBRARY_STATIC).addDependencies(xcodeProviderBuilder,new Attribute(ObjcProtoLibraryRule.LIBPROTOBUF_ATTR,Mode.TARGET)).registerActions(xcodeProviderBuilder.build());
  return ObjcRuleClasses.ruleConfiguredTarget(ruleContext,filesToBuild.build()).addProvider(XcodeProvider.class,xcodeProviderBuilder.build()).addProvider(ObjcProvider.class,common.getObjcProvider()).build();
}
