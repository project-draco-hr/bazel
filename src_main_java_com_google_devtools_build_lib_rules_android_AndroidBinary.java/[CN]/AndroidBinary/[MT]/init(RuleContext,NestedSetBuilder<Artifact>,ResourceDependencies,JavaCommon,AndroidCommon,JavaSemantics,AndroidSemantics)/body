{
  if (getMultidexMode(ruleContext) != MultidexMode.LEGACY && ruleContext.attributes().isAttributeValueExplicitlySpecified("main_dex_proguard_specs")) {
    ruleContext.throwWithAttributeError("main_dex_proguard_specs","The " + "'main_dex_proguard_specs' attribute is only allowed if 'multidex' is set to 'legacy'");
  }
  if (ruleContext.attributes().isAttributeValueExplicitlySpecified("proguard_apply_mapping") && ruleContext.attributes().get(ProguardHelper.PROGUARD_SPECS,BuildType.LABEL_LIST).isEmpty()) {
    ruleContext.throwWithAttributeError("proguard_apply_mapping","'proguard_apply_mapping' can only be used when 'proguard_specs' is also set");
  }
  Multimap<String,TransitiveInfoCollection> depsByArchitecture=MultimapBuilder.treeKeys().arrayListValues().build();
  AndroidConfiguration config=ruleContext.getFragment(AndroidConfiguration.class);
  if (config.isFatApk()) {
    for (    Map.Entry<String,? extends List<? extends TransitiveInfoCollection>> entry : ruleContext.getSplitPrerequisites("deps").entrySet()) {
      depsByArchitecture.putAll(entry.getKey(),entry.getValue());
    }
  }
 else {
    depsByArchitecture.putAll(config.getCpu(),ruleContext.getPrerequisites("deps",Mode.TARGET));
  }
  Map<String,BuildConfiguration> configurationMap=new LinkedHashMap<>();
  Map<String,CcToolchainProvider> toolchainMap=new LinkedHashMap<>();
  if (config.isFatApk()) {
    for (    Map.Entry<String,? extends List<? extends TransitiveInfoCollection>> entry : ruleContext.getSplitPrerequisites(":cc_toolchain_split").entrySet()) {
      TransitiveInfoCollection dep=Iterables.getOnlyElement(entry.getValue());
      CcToolchainProvider toolchain=CppHelper.getToolchain(ruleContext,dep);
      configurationMap.put(entry.getKey(),dep.getConfiguration());
      toolchainMap.put(entry.getKey(),toolchain);
    }
  }
 else {
    configurationMap.put(config.getCpu(),ruleContext.getConfiguration());
    toolchainMap.put(config.getCpu(),CppHelper.getToolchain(ruleContext));
  }
  NativeLibs nativeLibs=shouldLinkNativeDeps(ruleContext) ? NativeLibs.fromLinkedNativeDeps(ruleContext,androidSemantics.getNativeDepsFileName(),depsByArchitecture,toolchainMap,configurationMap) : NativeLibs.fromPrecompiledObjects(ruleContext,depsByArchitecture);
  ApplicationManifest applicationManifest;
  ResourceApk splitResourceApk;
  ResourceApk incrementalResourceApk;
  ResourceApk resourceApk;
  if (LocalResourceContainer.definesAndroidResources(ruleContext.attributes())) {
    LocalResourceContainer.validateRuleContext(ruleContext);
    ApplicationManifest ruleManifest=androidSemantics.getManifestForRule(ruleContext);
    String applicationId=ruleContext.attributes().get("application_id",Type.STRING);
    String versionCode=getExpandedMakeVarsForAttr(ruleContext,"version_code");
    String versionName=getExpandedMakeVarsForAttr(ruleContext,"version_name");
    Map<String,String> manifestValues=ruleContext.attributes().get("manifest_values",Type.STRING_DICT);
    if (manifestValues != null) {
      if (manifestValues.containsKey("applicationId")) {
        applicationId=manifestValues.get("applicationId");
      }
      if (manifestValues.containsKey("versionCode")) {
        versionCode=ruleContext.expandMakeVariables("manifest_values",manifestValues.get("versionCode"));
      }
      if (manifestValues.containsKey("versionName")) {
        versionName=ruleContext.expandMakeVariables("manifest_values",manifestValues.get("versionName"));
      }
    }
    applicationManifest=ruleManifest.mergeWith(ruleContext,resourceDeps);
    resourceApk=applicationManifest.packWithDataAndResources(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_APK),ruleContext,false,resourceDeps,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT),null,ruleContext.getTokenizedStringListAttr("resource_configuration_filters"),ruleContext.getTokenizedStringListAttr("nocompress_extensions"),ruleContext.attributes().get("crunch_png",Type.BOOLEAN),ruleContext.getTokenizedStringListAttr("densities"),applicationId,versionCode,versionName,false,ProguardHelper.getProguardConfigArtifact(ruleContext,""),createMainDexProguardSpec(ruleContext),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP));
    ruleContext.assertNoErrors();
    incrementalResourceApk=applicationManifest.addStubApplication(ruleContext).packWithDataAndResources(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_INCREMENTAL_RESOURCES_APK),ruleContext,false,resourceDeps,null,null,ruleContext.getTokenizedStringListAttr("resource_configuration_filters"),ruleContext.getTokenizedStringListAttr("nocompress_extensions"),ruleContext.attributes().get("crunch_png",Type.BOOLEAN),ruleContext.getTokenizedStringListAttr("densities"),applicationId,versionCode,versionName,true,ProguardHelper.getProguardConfigArtifact(ruleContext,"incremental"),null,null,null);
    ruleContext.assertNoErrors();
    splitResourceApk=applicationManifest.createSplitManifest(ruleContext,"android_resources",false).packWithDataAndResources(getDxArtifact(ruleContext,"android_resources.ap_"),ruleContext,false,resourceDeps,null,null,ruleContext.getTokenizedStringListAttr("resource_configuration_filters"),ruleContext.getTokenizedStringListAttr("nocompress_extensions"),ruleContext.attributes().get("crunch_png",Type.BOOLEAN),ruleContext.getTokenizedStringListAttr("densities"),applicationId,versionCode,versionName,true,ProguardHelper.getProguardConfigArtifact(ruleContext,"incremental_split"),null,null,null);
    ruleContext.assertNoErrors();
  }
 else {
    if (!ruleContext.attributes().get("crunch_png",Type.BOOLEAN)) {
      ruleContext.throwWithRuleError("Setting crunch_png = 0 is not supported for android_binary" + " rules which depend on android_resources rules.");
    }
    ApplicationManifest resourcesManifest=ApplicationManifest.fromResourcesRule(ruleContext);
    if (resourcesManifest == null) {
      throw new RuleErrorException();
    }
    applicationManifest=resourcesManifest.mergeWith(ruleContext,resourceDeps);
    if (shouldRegenerate(ruleContext,resourceDeps)) {
      resourceApk=applicationManifest.packWithResources(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_APK),ruleContext,resourceDeps,true,ProguardHelper.getProguardConfigArtifact(ruleContext,""),createMainDexProguardSpec(ruleContext));
    }
 else {
      resourceApk=applicationManifest.useCurrentResources(ruleContext,ProguardHelper.getProguardConfigArtifact(ruleContext,""),createMainDexProguardSpec(ruleContext));
    }
    incrementalResourceApk=applicationManifest.addStubApplication(ruleContext).packWithResources(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_INCREMENTAL_RESOURCES_APK),ruleContext,resourceDeps,false,ProguardHelper.getProguardConfigArtifact(ruleContext,"incremental"),null);
    ruleContext.assertNoErrors();
    splitResourceApk=applicationManifest.createSplitManifest(ruleContext,"android_resources",false).packWithResources(getDxArtifact(ruleContext,"android_resources.ap_"),ruleContext,resourceDeps,false,ProguardHelper.getProguardConfigArtifact(ruleContext,"incremental_split"),null);
    ruleContext.assertNoErrors();
  }
  JavaTargetAttributes resourceClasses=androidCommon.init(javaSemantics,androidSemantics,resourceApk,ruleContext.getConfiguration().isCodeCoverageEnabled(),true);
  ruleContext.assertNoErrors();
  Artifact deployJar=createDeployJar(ruleContext,javaSemantics,androidCommon,resourceClasses,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_BINARY_DEPLOY_JAR));
  Artifact proguardMapping=ruleContext.getPrerequisiteArtifact("proguard_apply_mapping",Mode.TARGET);
  return createAndroidBinary(ruleContext,filesBuilder,deployJar,false,javaCommon,androidCommon,javaSemantics,androidSemantics,nativeLibs,applicationManifest,resourceApk,incrementalResourceApk,splitResourceApk,true,resourceClasses,ImmutableList.<Artifact>of(),ImmutableList.<Artifact>of(),proguardMapping);
}
