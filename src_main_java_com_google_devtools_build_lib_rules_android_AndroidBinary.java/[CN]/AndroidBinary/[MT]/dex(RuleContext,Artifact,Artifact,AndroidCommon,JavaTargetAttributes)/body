{
  List<String> dexopts=ruleContext.getTokenizedStringListAttr("dexopts");
  MultidexMode multidexMode=getMultidexMode(ruleContext);
  String classesDexFileName=multidexMode.getOutputDexFilename();
  Artifact classesDex=AndroidBinary.getDxArtifact(ruleContext,classesDexFileName);
  if (!AndroidBinary.supportsMultidexMode(ruleContext,multidexMode)) {
    ruleContext.ruleError("Multidex mode \"" + multidexMode.getAttributeValue() + "\" not supported by this version of the Android SDK");
    return null;
  }
  int dexShards=ruleContext.attributes().get("dex_shards",Type.INTEGER);
  if (dexShards > 1 && multidexMode == MultidexMode.OFF) {
    ruleContext.ruleError(".dex sharding is only available in multidex mode");
    return null;
  }
  Artifact mainDexList=ruleContext.getPrerequisiteArtifact("main_dex_list",Mode.TARGET);
  if ((mainDexList != null && multidexMode != MultidexMode.MANUAL_MAIN_DEX) || (mainDexList == null && multidexMode == MultidexMode.MANUAL_MAIN_DEX)) {
    ruleContext.ruleError("Both \"main_dex_list\" and \"multidex='manual_main_dex'\" must be specified.");
    return null;
  }
  if (multidexMode == MultidexMode.OFF) {
    AndroidCommon.createDexAction(ruleContext,proguardedJar,classesDex,dexopts,false,null);
    return new DexingOutput(classesDex,deployJar,ImmutableList.of(classesDex));
  }
 else {
    if (multidexMode == MultidexMode.LEGACY) {
      mainDexList=createMainDexListAction(ruleContext,proguardedJar);
    }
    if (dexShards > 1) {
      List<Artifact> shards=new ArrayList<>(dexShards);
      for (int i=1; i <= dexShards; i++) {
        shards.add(getDxArtifact(ruleContext,"shard" + i + ".jar"));
      }
      Artifact javaResourceJar=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.JAVA_RESOURCES_JAR);
      SpawnAction.Builder shardAction=new SpawnAction.Builder().setMnemonic("ShardClassesToDex").setProgressMessage("Sharding classes for dexing for " + ruleContext.getLabel()).setExecutable(ruleContext.getExecutablePrerequisite("$shuffle_jars",Mode.HOST)).addOutputs(shards).addOutput(javaResourceJar);
      CustomCommandLine.Builder shardCommandLine=CustomCommandLine.builder().addBeforeEachExecPath("--output_jar",shards).addExecPath("--output_resources",javaResourceJar);
      if (mainDexList != null) {
        shardCommandLine.addExecPath("--main_dex_filter",mainDexList);
        shardAction.addInput(mainDexList);
      }
      boolean useDexArchives=false;
      if (proguardedJar != deployJar) {
        shardCommandLine.addExecPath("--input_jar",proguardedJar);
        shardAction.addInput(proguardedJar);
      }
 else {
        Iterable<Artifact> classpath=Iterables.concat(common.getRuntimeJars(),attributes.getRuntimeClassPathForArchive());
        useDexArchives=AndroidCommon.getAndroidConfig(ruleContext).getIncrementalDexing() != IncrementalDexing.OFF && !Iterables.any(dexopts,new FlagMatcher(AndroidCommon.getAndroidConfig(ruleContext).getTargetDexoptsThatPreventIncrementalDexing()));
        if (useDexArchives) {
          classpath=Iterables.transform(classpath,collectDexArchives(ruleContext,common));
          shardCommandLine.add("--split_dexed_classes");
        }
        shardCommandLine.addBeforeEachExecPath("--input_jar",classpath);
        shardAction.addInputs(classpath);
      }
      shardAction.setCommandLine(shardCommandLine.build());
      ruleContext.registerAction(shardAction.build(ruleContext));
      List<Artifact> shardDexes=new ArrayList<>(dexShards);
      for (int i=1; i <= dexShards; i++) {
        Artifact shard=shards.get(i - 1);
        Artifact shardDex=getDxArtifact(ruleContext,"shard" + i + ".dex.zip");
        shardDexes.add(shardDex);
        if (useDexArchives) {
          String multidexStrategy=mainDexList != null && i == 1 ? "minimal" : "best_effort";
          createDexMergerAction(ruleContext,multidexStrategy,shard,shardDex);
        }
 else {
          AndroidCommon.createDexAction(ruleContext,shard,shardDex,dexopts,true,(Artifact)null);
        }
      }
      CommandLine mergeCommandLine=CustomCommandLine.builder().addBeforeEachExecPath("--input_zip",shardDexes).addExecPath("--output_zip",classesDex).build();
      ruleContext.registerAction(new SpawnAction.Builder().setMnemonic("MergeDexZips").setProgressMessage("Merging dex shards for " + ruleContext.getLabel()).setExecutable(ruleContext.getExecutablePrerequisite("$merge_dexzips",Mode.HOST)).addInputs(shardDexes).addOutput(classesDex).setCommandLine(mergeCommandLine).build(ruleContext));
      return new DexingOutput(classesDex,javaResourceJar,shardDexes);
    }
 else {
      Artifact classesDexIntermediate=AndroidBinary.getDxArtifact(ruleContext,"intermediate_" + classesDexFileName);
      AndroidCommon.createDexAction(ruleContext,proguardedJar,classesDexIntermediate,dexopts,true,mainDexList);
      createCleanDexZipAction(ruleContext,classesDexIntermediate,classesDex);
      return new DexingOutput(classesDex,deployJar,ImmutableList.of(classesDex));
    }
  }
}
