{
  Preconditions.checkState(invalidationType != InvalidationType.DELETED,key);
  final boolean isChanged=(invalidationType == InvalidationType.CHANGED);
  final Pair<SkyKey,InvalidationType> invalidationPair=Pair.of(key,invalidationType);
  if (!visited.add(invalidationPair)) {
    return;
  }
  pendingVisitations.add(invalidationPair);
  enqueue(new Runnable(){
    @Override public void run(){
      NodeEntry entry=graph.get(key);
      if (entry == null) {
        Preconditions.checkState(!mustExist,"%s does not exist in the graph but was enqueued for dirtying by another node",key);
        pendingVisitations.remove(invalidationPair);
        return;
      }
      if (entry.isChanged() || (!isChanged && entry.isDirty())) {
        pendingVisitations.remove(invalidationPair);
        return;
      }
      Iterable<SkyKey> deps=entry.markDirty(isChanged);
      if (deps == null) {
        pendingVisitations.remove(invalidationPair);
        return;
      }
      for (      SkyKey reverseDep : entry.getReverseDeps()) {
        visit(reverseDep,InvalidationType.DIRTIED,MUST_EXIST);
      }
      Map<SkyKey,NodeEntry> children=graph.getBatch(deps);
      if (children.size() != Iterables.size(deps)) {
        Set<SkyKey> depsSet=ImmutableSet.copyOf(deps);
        throw new IllegalStateException("Mismatch in getBatch: " + key + ", "+ entry+ "\n"+ Sets.difference(depsSet,children.keySet())+ "\n"+ Sets.difference(children.keySet(),depsSet));
      }
      for (      NodeEntry child : children.values()) {
        child.removeReverseDep(key);
      }
      informInvalidationReceiver(key,EvaluationProgressReceiver.InvalidationState.DIRTY);
      dirtyKeyTracker.dirty(key);
      pendingVisitations.remove(invalidationPair);
    }
  }
);
}
