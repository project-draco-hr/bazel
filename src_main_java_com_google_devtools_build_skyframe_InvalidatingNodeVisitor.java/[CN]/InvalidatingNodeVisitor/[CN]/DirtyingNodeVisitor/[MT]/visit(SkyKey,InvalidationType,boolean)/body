{
  Preconditions.checkState(invalidationType != InvalidationType.DELETED,key);
  final boolean isChanged=(invalidationType == InvalidationType.CHANGED);
  final Pair<SkyKey,InvalidationType> invalidationPair=Pair.of(key,invalidationType);
  if (!visited.add(invalidationPair)) {
    return;
  }
  pendingVisitations.add(invalidationPair);
  executor.execute(new Runnable(){
    @Override public void run(){
      ThinNodeEntry entry=graph.get(key);
      if (entry == null) {
        Preconditions.checkState(!mustExist,"%s does not exist in the graph but was enqueued for dirtying by another node",key);
        pendingVisitations.remove(invalidationPair);
        return;
      }
      if (entry.isChanged() || (!isChanged && entry.isDirty())) {
        pendingVisitations.remove(invalidationPair);
        return;
      }
      MarkedDirtyResult markedDirtyResult=entry.markDirty(isChanged);
      if (markedDirtyResult == null) {
        pendingVisitations.remove(invalidationPair);
        return;
      }
      for (      SkyKey reverseDep : markedDirtyResult.getReverseDepsUnsafe()) {
        visit(reverseDep,InvalidationType.DIRTIED,MUST_EXIST);
      }
      informInvalidationReceiver(key,EvaluationProgressReceiver.InvalidationState.DIRTY);
      dirtyKeyTracker.dirty(key);
      pendingVisitations.remove(invalidationPair);
    }
  }
);
}
