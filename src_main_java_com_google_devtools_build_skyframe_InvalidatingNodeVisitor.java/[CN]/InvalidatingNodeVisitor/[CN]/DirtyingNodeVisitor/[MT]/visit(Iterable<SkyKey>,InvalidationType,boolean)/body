{
  Preconditions.checkState(invalidationType != InvalidationType.DELETED,keys);
  final boolean isChanged=(invalidationType == InvalidationType.CHANGED);
  int size=Iterables.size(keys);
  ArrayList<Pair<SkyKey,InvalidationType>> invalidationPairs=new ArrayList<>(size);
  for (  SkyKey key : keys) {
    Pair<SkyKey,InvalidationType> invalidationPair=Pair.of(key,invalidationType);
    if (visited.add(invalidationPair)) {
      invalidationPairs.add(invalidationPair);
    }
  }
  List<SkyKey> keysToGet=Lists.transform(invalidationPairs,Pair.<SkyKey,InvalidationType>firstFunction());
  pendingVisitations.addAll(invalidationPairs);
  final Map<SkyKey,? extends ThinNodeEntry> entries=graph.getBatch(keysToGet);
  for (  final Pair<SkyKey,InvalidationType> invalidationPair : invalidationPairs) {
    executor.execute(new Runnable(){
      @Override public void run(){
        SkyKey key=invalidationPair.getFirst();
        ThinNodeEntry entry=entries.get(key);
        if (entry == null) {
          Preconditions.checkState(!mustExist,"%s does not exist in the graph but was enqueued for dirtying by another " + "node",key);
          pendingVisitations.remove(invalidationPair);
          return;
        }
        if (entry.isChanged() || (!isChanged && entry.isDirty())) {
          pendingVisitations.remove(invalidationPair);
          return;
        }
        MarkedDirtyResult markedDirtyResult=entry.markDirty(isChanged);
        if (markedDirtyResult == null) {
          pendingVisitations.remove(invalidationPair);
          return;
        }
        visit(markedDirtyResult.getReverseDepsUnsafe(),InvalidationType.DIRTIED,MUST_EXIST);
        informInvalidationReceiver(key,EvaluationProgressReceiver.InvalidationState.DIRTY);
        dirtyKeyTracker.dirty(key);
        pendingVisitations.remove(invalidationPair);
      }
    }
);
  }
}
