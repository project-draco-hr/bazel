{
  validateOptions(request);
  BuildOptions buildOptions=runtime.createBuildOptions(request);
  runtime.setupPackageCache(request.getPackageCacheOptions(),DefaultsPackage.getDefaultsPackageContent(buildOptions));
  ExecutionTool executionTool=null;
  LoadingResult loadingResult=null;
  BuildConfigurationCollection configurations=null;
  try {
    env.getEventBus().post(new BuildStartingEvent(runtime.getOutputFileSystem(),request));
    LOG.info("Build identifier: " + request.getId());
    executionTool=new ExecutionTool(env,request);
    if (needsExecutionPhase(request.getBuildOptions())) {
      executionTool.init();
    }
    loadingResult=runLoadingPhase(request,validator);
    if (!request.getMultiCpus().isEmpty()) {
      getReporter().handle(Event.warn("The --experimental_multi_cpu option is _very_ experimental and only intended for " + "internal testing at this time. If you do not work on the build tool, then you " + "should stop now!"));
      if (!"build".equals(request.getCommandName()) && !"test".equals(request.getCommandName())) {
        throw new InvalidConfigurationException("The experimental setting to select multiple CPUs is only supported for 'build' and " + "'test' right now!");
      }
    }
    configurations=runtime.getSkyframeExecutor().createConfigurations(runtime.getConfigurationFactory(),buildOptions,runtime.getDirectories(),request.getMultiCpus(),request.getViewOptions().keepGoing);
    env.getEventBus().post(new ConfigurationsCreatedEvent(configurations));
    env.throwPendingException();
    if (configurations.getTargetConfigurations().size() == 1) {
      env.getEventBus().post(new MakeEnvironmentEvent(configurations.getTargetConfigurations().get(0).getMakeEnvironment()));
    }
    LOG.info("Configurations created");
    AnalysisResult analysisResult=runAnalysisPhase(request,loadingResult,configurations);
    result.setActualTargets(analysisResult.getTargetsToBuild());
    result.setTestTargets(analysisResult.getTargetsToTest());
    checkTargetEnvironmentRestrictions(analysisResult.getTargetsToBuild(),runtime.getPackageManager());
    reportTargets(analysisResult);
    if (needsExecutionPhase(request.getBuildOptions())) {
      runtime.getSkyframeExecutor().injectTopLevelContext(request.getTopLevelArtifactContext());
      executionTool.executeBuild(request.getId(),analysisResult,result,configurations,transformPackageRoots(loadingResult.getPackageRoots()));
    }
    String delayedErrorMsg=analysisResult.getError();
    if (delayedErrorMsg != null) {
      throw new BuildFailedException(delayedErrorMsg);
    }
  }
 catch (  RuntimeException e) {
    request.getOutErr().printErrLn("Unhandled exception thrown during build; message: " + e.getMessage());
    throw e;
  }
 finally {
    long versionWindow=request.getViewOptions().versionWindowForDirtyNodeGc;
    if (versionWindow != -1) {
      runtime.getSkyframeExecutor().deleteOldNodes(versionWindow);
    }
    if (executionTool != null) {
      executionTool.shutdown();
    }
    env.getEventBus().post(new BuildInfoEvent(runtime.getworkspaceStatusActionFactory().createDummyWorkspaceStatus()));
  }
  if (loadingResult != null && loadingResult.hasTargetPatternError()) {
    throw new BuildFailedException("execution phase successful, but there were errors " + "parsing the target pattern");
  }
}
