{
switch (attrPb.getType()) {
case INTEGER:
    return attrPb.hasIntValue() ? attrPb.getIntValue() : null;
case STRING:
  if (!attrPb.hasStringValue()) {
    return null;
  }
 else   if (expectedType == BuildType.NODEP_LABEL) {
    return deserializeLabel(attrPb.getStringValue());
  }
 else {
    return attrPb.getStringValue();
  }
case LABEL:
case OUTPUT:
return attrPb.hasStringValue() ? deserializeLabel(attrPb.getStringValue()) : null;
case STRING_LIST:
if (expectedType == BuildType.NODEP_LABEL_LIST) {
return deserializeGlobs(deserializeLabels(attrPb.getStringListValueList()),attrPb);
}
 else {
return deserializeGlobs(ImmutableList.copyOf(attrPb.getStringListValueList()),attrPb);
}
case LABEL_LIST:
case OUTPUT_LIST:
return deserializeGlobs(deserializeLabels(attrPb.getStringListValueList()),attrPb);
case DISTRIBUTION_SET:
return deserializeDistribs(attrPb.getStringListValueList());
case LICENSE:
return attrPb.hasLicense() ? deserializeLicense(attrPb.getLicense()) : null;
case STRING_DICT:
{
ImmutableMap.Builder<String,String> builder=ImmutableMap.builder();
HashSet<String> keysSeenSoFar=Sets.newHashSet();
for (Build.StringDictEntry entry : attrPb.getStringDictValueList()) {
String key=entry.getKey();
if (keysSeenSoFar.add(key)) {
builder.put(key,entry.getValue());
}
}
return builder.build();
}
case STRING_DICT_UNARY:
{
ImmutableMap.Builder<String,String> builder=ImmutableMap.builder();
HashSet<String> keysSeenSoFar=Sets.newHashSet();
for (StringDictUnaryEntry entry : attrPb.getStringDictUnaryValueList()) {
String key=entry.getKey();
if (keysSeenSoFar.add(key)) {
builder.put(key,entry.getValue());
}
}
return builder.build();
}
case FILESET_ENTRY_LIST:
return deserializeFilesetEntries(attrPb.getFilesetListValueList());
case LABEL_LIST_DICT:
{
ImmutableMap.Builder<String,List<Label>> builder=ImmutableMap.builder();
HashSet<String> keysSeenSoFar=Sets.newHashSet();
for (Build.LabelListDictEntry entry : attrPb.getLabelListDictValueList()) {
String key=entry.getKey();
if (keysSeenSoFar.add(key)) {
builder.put(key,deserializeLabels(entry.getValueList()));
}
}
return builder.build();
}
case STRING_LIST_DICT:
{
ImmutableMap.Builder<String,List<String>> builder=ImmutableMap.builder();
HashSet<String> keysSeenSoFar=Sets.newHashSet();
for (Build.StringListDictEntry entry : attrPb.getStringListDictValueList()) {
String key=entry.getKey();
if (keysSeenSoFar.add(key)) {
builder.put(key,ImmutableList.copyOf(entry.getValueList()));
}
}
return builder.build();
}
case BOOLEAN:
return attrPb.hasBooleanValue() ? attrPb.getBooleanValue() : null;
case TRISTATE:
return attrPb.hasStringValue() ? deserializeTriStateValue(attrPb.getStringValue()) : null;
case INTEGER_LIST:
return ImmutableList.copyOf(attrPb.getIntListValueList());
default :
throw new PackageDeserializationException("Invalid discriminator: " + attrPb.getType());
}
}
