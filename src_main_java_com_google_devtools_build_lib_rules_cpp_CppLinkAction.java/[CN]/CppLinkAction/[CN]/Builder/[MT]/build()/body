{
  if (interfaceOutput != null && (fake || linkType != LinkTargetType.DYNAMIC_LIBRARY)) {
    throw new RuntimeException("Interface output can only be used " + "with non-fake DYNAMIC_LIBRARY targets");
  }
  final ImmutableList<Artifact> buildInfoHeaderArtifacts=!linkstamps.isEmpty() ? ruleContext.getBuildInfo(CppBuildInfo.KEY) : ImmutableList.<Artifact>of();
  boolean needWholeArchive=wholeArchive || needWholeArchive(linkStaticness,linkType,linkopts,isNativeDeps,cppConfiguration);
  NestedSet<LibraryToLink> uniqueLibraries=libraries.build();
  final Iterable<Artifact> filteredNonLibraryArtifacts=filterLinkerInputArtifacts(LinkerInputs.toLibraryArtifacts(nonLibraries));
  final Iterable<LinkerInput> linkerInputs=IterablesChain.<LinkerInput>builder().add(ImmutableList.copyOf(filterLinkerInputs(nonLibraries))).add(ImmutableIterable.from(Link.mergeInputsCmdLine(uniqueLibraries,needWholeArchive,cppConfiguration.archiveType()))).build();
  final ImmutableSet<String> features=(ruleContext == null) ? ImmutableSet.<String>of() : ruleContext.getFeatures();
  final LibraryToLink outputLibrary=LinkerInputs.newInputLibrary(output,filteredNonLibraryArtifacts);
  final LibraryToLink interfaceOutputLibrary=interfaceOutput == null ? null : LinkerInputs.newInputLibrary(interfaceOutput,filteredNonLibraryArtifacts);
  final ImmutableMap<Artifact,Artifact> linkstampMap=mapLinkstampsToOutputs(linkstamps,ruleContext,output);
  final ImmutableList<Artifact> actionOutputs=constructOutputs(outputLibrary.getArtifact(),linkstampMap.values(),interfaceOutputLibrary == null ? null : interfaceOutputLibrary.getArtifact(),symbolCounts);
  @Nullable final Artifact paramFile=canSplitCommandLine() ? ParamFileHelper.getParamsFile(analysisEnvironment,configuration,outputLibrary.getArtifact()) : null;
  LinkCommandLine linkCommandLine=new LinkCommandLine.Builder(configuration,getOwner(),ruleContext).setOutput(outputLibrary.getArtifact()).setInterfaceOutput(interfaceOutput).setSymbolCountsOutput(symbolCounts).setBuildInfoHeaderArtifacts(buildInfoHeaderArtifacts).setLinkerInputs(linkerInputs).setRuntimeInputs(ImmutableList.copyOf(LinkerInputs.simpleLinkerInputs(runtimeInputs))).setLinkTargetType(linkType).setLinkStaticness(linkStaticness).setLinkopts(ImmutableList.copyOf(linkopts)).setFeatures(features).setLinkstamps(linkstampMap).addLinkstampCompileOptions(linkstampOptions).setRuntimeSolibDir(linkType.isStaticLibraryLink() ? null : runtimeSolibDir).setNativeDeps(isNativeDeps).setUseTestOnlyFlags(useTestOnlyFlags).setNeedWholeArchive(needWholeArchive).setInterfaceSoBuilder(getInterfaceSoBuilder()).setParamFile(paramFile).build();
  NestedSetBuilder<Artifact> dependencyInputsBuilder=NestedSetBuilder.stableOrder();
  dependencyInputsBuilder.addAll(buildInfoHeaderArtifacts);
  dependencyInputsBuilder.addAll(linkstamps);
  dependencyInputsBuilder.addTransitive(crosstoolInputs);
  if (runtimeMiddleman != null) {
    dependencyInputsBuilder.add(runtimeMiddleman);
  }
  dependencyInputsBuilder.addTransitive(compilationInputs.build());
  Iterable<Artifact> expandedInputs=LinkerInputs.toLibraryArtifacts(Link.mergeInputsDependencies(uniqueLibraries,needWholeArchive,cppConfiguration.archiveType()));
  IterablesChain.Builder<Artifact> inputsBuilder=IterablesChain.<Artifact>builder().add(ImmutableList.copyOf(LinkerInputs.toLibraryArtifacts(nonLibraries))).add(dependencyInputsBuilder.build()).add(ImmutableIterable.from(expandedInputs));
  if (linkCommandLine.getParamFile() != null) {
    inputsBuilder.add(ImmutableList.of(linkCommandLine.getParamFile()));
    Action parameterFileWriteAction=new ParameterFileWriteAction(getOwner(),paramFile,linkCommandLine.paramCmdLine(),ParameterFile.ParameterFileType.UNQUOTED,ISO_8859_1);
    analysisEnvironment.registerAction(parameterFileWriteAction);
  }
  return new CppLinkAction(getOwner(),inputsBuilder.deduplicate().build(),actionOutputs,cppConfiguration,outputLibrary,interfaceOutputLibrary,fake,linkCommandLine);
}
