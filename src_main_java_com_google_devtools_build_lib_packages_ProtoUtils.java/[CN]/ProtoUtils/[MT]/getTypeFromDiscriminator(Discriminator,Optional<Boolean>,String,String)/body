{
  Preconditions.checkArgument(INVERSE_TYPE_MAP.containsKey(discriminator));
  ImmutableSet<Type<?>> possibleTypes=ProtoUtils.getTypesFromDiscriminator(discriminator);
  Type<?> preciseType;
  if (possibleTypes.size() == 1) {
    preciseType=Iterables.getOnlyElement(possibleTypes);
  }
 else {
    Preconditions.checkArgument(nodeps.isPresent(),"Nodeps hint is required when discriminator is associated with more than one type." + " Discriminator: \"%s\", Rule class: \"%s\", Attr: \"%s\"",discriminator,ruleClassName,attrName);
    if (nodeps.get()) {
      Set<Type<?>> nodepType=Sets.filter(possibleTypes,Predicates.in(NODEP_TYPES));
      Preconditions.checkState(nodepType.size() == 1,"There should be exactly one NODEP type associated with discriminator \"%s\"" + ", but found these: %s. Rule class: \"%s\", Attr: \"%s\"",discriminator,nodepType,ruleClassName,attrName);
      preciseType=Iterables.getOnlyElement(nodepType);
    }
 else {
      Set<Type<?>> notNodepType=Sets.filter(possibleTypes,Predicates.not(Predicates.in(NODEP_TYPES)));
      Preconditions.checkState(notNodepType.size() == 1,"There should be exactly one non-NODEP type associated with discriminator \"%s\"" + ", but found these: %s. Rule class: \"%s\", Attr: \"%s\"",discriminator,notNodepType,ruleClassName,attrName);
      preciseType=Iterables.getOnlyElement(notNodepType);
    }
  }
  return preciseType;
}
