{
  Preconditions.checkState(keysRequested.isEmpty(),"resolver should only be called once: %s %s",keysRequested,execPaths);
  Map<PathFragment,SkyKey> depKeys=new HashMap<>();
  for (  PathFragment path : execPaths) {
    SkyKey depKey=ContainingPackageLookupValue.key(PackageIdentifier.createInDefaultRepo(path));
    depKeys.put(path,depKey);
    keysRequested.add(depKey);
  }
  Map<SkyKey,ValueOrException2<NoSuchPackageException,InconsistentFilesystemException>> values=env.getValuesOrThrow(depKeys.values(),NoSuchPackageException.class,InconsistentFilesystemException.class);
  if (env.valuesMissing()) {
    return null;
  }
  Map<PathFragment,Root> result=new HashMap<>();
  for (  PathFragment path : execPaths) {
    ContainingPackageLookupValue value;
    try {
      value=(ContainingPackageLookupValue)values.get(depKeys.get(path)).get();
    }
 catch (    NoSuchPackageException|InconsistentFilesystemException e) {
      throw new PackageRootResolutionException("Could not determine containing package for " + path,e);
    }
    if (value.hasContainingPackage()) {
      result.put(path,Root.asSourceRoot(value.getContainingPackageRoot()));
    }
 else {
      result.put(path,null);
    }
  }
  return result;
}
