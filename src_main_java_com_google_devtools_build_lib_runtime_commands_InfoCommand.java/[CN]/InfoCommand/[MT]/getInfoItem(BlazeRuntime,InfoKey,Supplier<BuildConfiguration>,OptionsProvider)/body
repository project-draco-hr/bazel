{
switch (key) {
case WORKSPACE:
    return runtime.getWorkspace();
case INSTALL_BASE:
  return runtime.getDirectories().getInstallBase();
case OUTPUT_BASE:
return runtime.getOutputBase();
case EXECUTION_ROOT:
return runtime.getExecRoot();
case OUTPUT_PATH:
return runtime.getDirectories().getOutputPath();
case BLAZE_BIN:
return configurationSupplier.get().getBinDirectory().getPath();
case BLAZE_GENFILES:
return configurationSupplier.get().getGenfilesDirectory().getPath();
case BLAZE_TESTLOGS:
return configurationSupplier.get().getTestLogsDirectory().getPath();
case COMMAND_LOG:
return BlazeCommandDispatcher.getCommandLogPath(runtime.getOutputBase());
case MESSAGE_LOG:
return runtime.getOutputBase().getRelative("message.log");
case RELEASE:
return BlazeVersionInfo.instance().getReleaseName();
case SERVER_PID:
return OsUtils.getpid();
case PACKAGE_PATH:
return getPackagePath(options);
case GC_COUNT:
case GC_TIME:
int gcCount=0;
int gcTime=0;
for (GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {
gcCount+=gcBean.getCollectionCount();
gcTime+=gcBean.getCollectionTime();
}
if (key == InfoKey.GC_COUNT) {
return gcCount + "";
}
 else {
return gcTime + "ms";
}
case MAX_HEAP_SIZE:
return StringUtilities.prettyPrintBytes(getMemoryUsage().getMax());
case USED_HEAP_SIZE:
case COMMITTED_HEAP_SIZE:
return StringUtilities.prettyPrintBytes(key == InfoKey.USED_HEAP_SIZE ? getMemoryUsage().getUsed() : getMemoryUsage().getCommitted());
case USED_HEAP_SIZE_AFTER_GC:
System.gc();
return StringUtilities.prettyPrintBytes(getMemoryUsage().getUsed());
case DEFAULTS_PACKAGE:
return runtime.getDefaultsPackageContent();
case BUILD_LANGUAGE:
return getBuildLanguageDefinition(runtime.getRuleClassProvider());
case DEFAULT_PACKAGE_PATH:
return Joiner.on(":").join(Constants.DEFAULT_PACKAGE_PATH);
default :
throw new IllegalArgumentException("missing implementation for " + key);
}
}
