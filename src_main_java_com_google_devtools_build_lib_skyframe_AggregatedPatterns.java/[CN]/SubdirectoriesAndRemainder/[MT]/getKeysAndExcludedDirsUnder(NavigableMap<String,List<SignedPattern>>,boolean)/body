{
  ImmutableList.Builder<TargetPatternKey> keysBuilder=ImmutableList.builder();
  ImmutableSet.Builder<String> excludedDirsBuilder=ImmutableSet.builder();
  Iterator<Entry<String,List<SignedPattern>>> iterator=directories.entrySet().iterator();
  while (iterator.hasNext()) {
    Entry<String,List<SignedPattern>> directoryEntry=iterator.next();
    DirectoryInclusion directoryInclusion=DirectoryInclusion.from(includedByDefault);
    Iterable<SignedPattern> directoryPatterns=directoryEntry.getValue();
    for (    SignedPattern signedPattern : directoryPatterns) {
      if (isTargetsBelowDirectory(signedPattern)) {
        if (!signedPattern.isPositive()) {
          excludedDirsBuilder.add(signedPattern.getPattern().getDirectory());
        }
        if (signedPattern.isPositive() != includedByDefault) {
          directoryInclusion=DirectoryInclusion.from(signedPattern.isPositive());
          SubdirectoriesAndRemainder subdirectoriesAndRemainder=getSubdirectoriesAndRemainder(directories,directoryEntry.getKey());
          NavigableMap<String,List<SignedPattern>> subMapForSubdirectories=subdirectoriesAndRemainder.getSubdirectoriesMap();
          KeysAndExcludedDirectories keysAndExcludedDirs=getKeysAndExcludedDirsUnder(subMapForSubdirectories,signedPattern.isPositive());
          if (signedPattern.isPositive()) {
            keysBuilder.add(createTargetPatternKey(signedPattern,policy,offset,keysAndExcludedDirs.getExcludedDirectories()));
          }
          keysBuilder.addAll(keysAndExcludedDirs.getKeys());
          iterator=subdirectoriesAndRemainder.getRemainder();
        }
      }
 else {
        boolean subtractingFromIncludedDirectory=directoryInclusion.equals(DirectoryInclusion.INCLUDED) && !signedPattern.isPositive();
        boolean addingToExcludedDirectory=directoryInclusion.equals(DirectoryInclusion.EXCLUDED) && signedPattern.isPositive();
        boolean alreadyMixed=directoryInclusion.equals(DirectoryInclusion.MIXED);
        if (subtractingFromIncludedDirectory || addingToExcludedDirectory || alreadyMixed) {
          keysBuilder.add(createTargetPatternKey(signedPattern,policy,offset));
          directoryInclusion=DirectoryInclusion.MIXED;
        }
      }
    }
  }
  return new KeysAndExcludedDirectories(keysBuilder.build(),excludedDirsBuilder.build());
}
