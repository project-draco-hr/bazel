{
  int start=token.left;
  expect(TokenKind.LBRACKET);
  if (token.kind == TokenKind.RBRACKET) {
    ListLiteral literal=ListLiteral.emptyList();
    setLocation(literal,start,token.right);
    nextToken();
    return literal;
  }
  Expression expression=parseNonTupleExpression();
  Preconditions.checkNotNull(expression,"null element in list in AST at %s:%s",token.left,token.right);
switch (token.kind) {
case RBRACKET:
{
      ListLiteral literal=ListLiteral.makeList(Collections.singletonList(expression));
      setLocation(literal,start,token.right);
      nextToken();
      return literal;
    }
case FOR:
{
    ListComprehension listComprehension=new ListComprehension(expression);
    do {
      nextToken();
      Expression loopVar=parseForLoopVariables();
      if (token.kind == TokenKind.IN) {
        nextToken();
        Expression listExpression=parseExpression();
        listComprehension.add(loopVar,listExpression);
      }
 else {
        break;
      }
      if (token.kind == TokenKind.RBRACKET) {
        setLocation(listComprehension,start,token.right);
        nextToken();
        return listComprehension;
      }
    }
 while (token.kind == TokenKind.FOR);
    syntaxError(token,"expected 'for' or ']'");
    int end=syncPast(LIST_TERMINATOR_SET);
    return makeErrorExpression(start,end);
  }
case COMMA:
{
  List<Expression> list=parseExprList();
  Preconditions.checkState(!list.contains(null),"null element in list in AST at %s:%s",token.left,token.right);
  list.add(0,expression);
  if (token.kind == TokenKind.RBRACKET) {
    ListLiteral literal=ListLiteral.makeList(list);
    setLocation(literal,start,token.right);
    nextToken();
    return literal;
  }
  expect(TokenKind.RBRACKET);
  int end=syncPast(LIST_TERMINATOR_SET);
  return makeErrorExpression(start,end);
}
default :
{
syntaxError(token,"expected ',', 'for' or ']'");
int end=syncPast(LIST_TERMINATOR_SET);
return makeErrorExpression(start,end);
}
}
}
