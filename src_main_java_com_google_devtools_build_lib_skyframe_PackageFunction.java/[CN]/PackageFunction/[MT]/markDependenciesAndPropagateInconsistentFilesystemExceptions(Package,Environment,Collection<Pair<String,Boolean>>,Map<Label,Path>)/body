{
  boolean packageWasOriginallyInError=pkg.containsErrors();
  boolean packageShouldBeInError=packageWasOriginallyInError;
  Set<SkyKey> subincludePackageLookupDepKeys=Sets.newHashSet();
  for (  Label label : pkg.getSubincludeLabels()) {
    subincludePackageLookupDepKeys.add(PackageLookupValue.key(label.getPackageIdentifier()));
  }
  Pair<? extends Map<PathFragment,PackageLookupValue>,Boolean> subincludePackageLookupResult=getPackageLookupDepsAndPropagateInconsistentFilesystemExceptions(pkg.getPackageIdentifier(),subincludePackageLookupDepKeys,env,packageWasOriginallyInError);
  Map<PathFragment,PackageLookupValue> subincludePackageLookupDeps=subincludePackageLookupResult.getFirst();
  packageShouldBeInError|=subincludePackageLookupResult.getSecond();
  List<SkyKey> subincludeFileDepKeys=Lists.newArrayList();
  for (  Entry<Label,Path> subincludeEntry : subincludes.entrySet()) {
    Label label=subincludeEntry.getKey();
    PackageLookupValue subincludePackageLookupValue=subincludePackageLookupDeps.get(label.getPackageFragment());
    if (subincludePackageLookupValue != null) {
      Path subincludeFilePath=subincludeEntry.getValue();
      if (subincludeFilePath != null) {
        if (!subincludePackageLookupValue.packageExists()) {
          throw new InternalInconsistentFilesystemException(pkg.getPackageIdentifier(),String.format("Unexpected package in %s. Was it modified during the build?",subincludeFilePath));
        }
        Path subincludeFilePathSkyframe=subincludePackageLookupValue.getRoot().getRelative(label.toPathFragment());
        if (!subincludeFilePathSkyframe.equals(subincludeFilePath)) {
          throw new InternalInconsistentFilesystemException(pkg.getPackageIdentifier(),String.format("Inconsistent package location for %s: '%s' vs '%s'. " + "Was the source tree modified during the build?",label.getPackageFragment(),subincludeFilePathSkyframe,subincludeFilePath));
        }
        SkyKey subincludeSkyKey=FileValue.key(RootedPath.toRootedPath(subincludePackageLookupValue.getRoot(),subincludeFilePath));
        subincludeFileDepKeys.add(subincludeSkyKey);
      }
    }
  }
  packageShouldBeInError|=markFileDepsAndPropagateInconsistentFilesystemExceptions(pkg.getPackageIdentifier(),subincludeFileDepKeys,env,packageWasOriginallyInError);
  PackageIdentifier packageId=pkg.getPackageIdentifier();
  List<SkyKey> globDepKeys=Lists.newArrayList();
  for (  Pair<String,Boolean> globPattern : globPatterns) {
    String pattern=globPattern.getFirst();
    boolean excludeDirs=globPattern.getSecond();
    SkyKey globSkyKey;
    try {
      globSkyKey=GlobValue.key(packageId,pattern,excludeDirs,PathFragment.EMPTY_FRAGMENT);
    }
 catch (    InvalidGlobPatternException e) {
      throw new IllegalStateException(e);
    }
    globDepKeys.add(globSkyKey);
  }
  packageShouldBeInError|=markGlobDepsAndPropagateInconsistentFilesystemExceptions(pkg.getPackageIdentifier(),globDepKeys,env,packageWasOriginallyInError);
  return packageShouldBeInError;
}
