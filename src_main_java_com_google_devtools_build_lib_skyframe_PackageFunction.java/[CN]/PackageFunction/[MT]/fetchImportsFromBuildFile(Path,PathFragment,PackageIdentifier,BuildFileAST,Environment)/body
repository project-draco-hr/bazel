{
  ImmutableMap<Location,PathFragment> imports=buildFileAST.getImports();
  Map<PathFragment,Extension> importMap=Maps.newHashMapWithExpectedSize(imports.size());
  ImmutableList.Builder<SkylarkFileDependency> fileDependencies=ImmutableList.builder();
  Map<SkyKey,ValueOrException4<SkylarkImportFailedException,InconsistentFilesystemException,ASTLookupInputException,BuildFileNotFoundException>> skylarkImportMap;
  Map<SkyKey,PathFragment> skylarkImports=Maps.newHashMapWithExpectedSize(imports.size());
  if (skylarkImportLookupFunctionForInlining != null) {
    skylarkImportMap=Maps.newHashMapWithExpectedSize(imports.size());
    for (    Map.Entry<Location,PathFragment> entry : imports.entrySet()) {
      SkyKey importKey=getImportKeyAndMaybeThrowException(entry,preludePath,buildFileFragment,packageId);
      skylarkImports.put(importKey,entry.getValue());
      ValueOrException4<SkylarkImportFailedException,InconsistentFilesystemException,ASTLookupInputException,BuildFileNotFoundException> lookupResult;
      try {
        SkyValue value=skylarkImportLookupFunctionForInlining.computeWithInlineCalls(importKey,env);
        if (value == null) {
          Preconditions.checkState(env.valuesMissing(),importKey);
          lookupResult=ValueOrExceptionUtils.ofNullValue();
        }
 else {
          lookupResult=ValueOrExceptionUtils.ofValue(value);
        }
      }
 catch (      SkyFunctionException e) {
        Exception cause=e.getCause();
        if (cause instanceof SkylarkImportFailedException) {
          lookupResult=ValueOrExceptionUtils.ofExn1((SkylarkImportFailedException)cause);
        }
 else         if (cause instanceof InconsistentFilesystemException) {
          lookupResult=ValueOrExceptionUtils.ofExn2((InconsistentFilesystemException)cause);
        }
 else         if (cause instanceof ASTLookupInputException) {
          lookupResult=ValueOrExceptionUtils.ofExn3((ASTLookupInputException)cause);
        }
 else         if (cause instanceof BuildFileNotFoundException) {
          lookupResult=ValueOrExceptionUtils.ofExn4((BuildFileNotFoundException)cause);
        }
 else {
          throw new IllegalStateException("Unexpected type for " + importKey,e);
        }
      }
      skylarkImportMap.put(importKey,lookupResult);
    }
  }
 else {
    for (    Map.Entry<Location,PathFragment> entry : imports.entrySet()) {
      skylarkImports.put(getImportKeyAndMaybeThrowException(entry,preludePath,buildFileFragment,packageId),entry.getValue());
    }
    skylarkImportMap=env.getValuesOrThrow(skylarkImports.keySet(),SkylarkImportFailedException.class,InconsistentFilesystemException.class,ASTLookupInputException.class,BuildFileNotFoundException.class);
  }
  for (  Map.Entry<SkyKey,ValueOrException4<SkylarkImportFailedException,InconsistentFilesystemException,ASTLookupInputException,BuildFileNotFoundException>> entry : skylarkImportMap.entrySet()) {
    SkylarkImportLookupValue importLookupValue;
    try {
      importLookupValue=(SkylarkImportLookupValue)entry.getValue().get();
    }
 catch (    SkylarkImportFailedException e) {
      env.getListener().handle(Event.error(Location.fromFile(buildFilePath),e.getMessage()));
      throw new PackageFunctionException(new BuildFileContainsErrorsException(packageId,e.getMessage()),Transience.PERSISTENT);
    }
catch (    InconsistentFilesystemException e) {
      throw new PackageFunctionException(new InternalInconsistentFilesystemException(packageId,e),Transience.PERSISTENT);
    }
catch (    ASTLookupInputException e) {
      throw new PackageFunctionException(new BuildFileContainsErrorsException(packageId,e.getMessage()),Transience.PERSISTENT);
    }
catch (    BuildFileNotFoundException e) {
      throw new PackageFunctionException(e,Transience.PERSISTENT);
    }
    if (importLookupValue == null) {
      Preconditions.checkState(env.valuesMissing(),entry);
    }
 else {
      importMap.put(skylarkImports.get(entry.getKey()),importLookupValue.getEnvironmentExtension());
      fileDependencies.add(importLookupValue.getDependency());
    }
  }
  if (env.valuesMissing()) {
    return null;
  }
  return new SkylarkImportResult(importMap,transitiveClosureOfLabels(fileDependencies.build()));
}
