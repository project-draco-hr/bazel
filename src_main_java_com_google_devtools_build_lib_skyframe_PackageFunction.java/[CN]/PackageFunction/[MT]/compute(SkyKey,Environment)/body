{
  PackageIdentifier packageId=(PackageIdentifier)key.argument();
  PathFragment packageNameFragment=packageId.getPackageFragment();
  SkyKey packageLookupKey=PackageLookupValue.key(packageId);
  PackageLookupValue packageLookupValue;
  try {
    packageLookupValue=(PackageLookupValue)env.getValueOrThrow(packageLookupKey,BuildFileNotFoundException.class,InconsistentFilesystemException.class);
  }
 catch (  BuildFileNotFoundException e) {
    throw new PackageFunctionException(e,Transience.PERSISTENT);
  }
catch (  InconsistentFilesystemException e) {
    throw new PackageFunctionException(new InternalInconsistentFilesystemException(packageId,e),Transience.PERSISTENT);
  }
  if (packageLookupValue == null) {
    return null;
  }
  if (!packageLookupValue.packageExists()) {
switch (packageLookupValue.getErrorReason()) {
case NO_BUILD_FILE:
case DELETED_PACKAGE:
      throw new PackageFunctionException(new BuildFileNotFoundException(packageId,packageLookupValue.getErrorMsg()),Transience.PERSISTENT);
case INVALID_PACKAGE_NAME:
    throw new PackageFunctionException(new InvalidPackageNameException(packageId,packageLookupValue.getErrorMsg()),Transience.PERSISTENT);
default :
  throw new IllegalStateException();
}
}
if (packageId.equals(Package.EXTERNAL_PACKAGE_IDENTIFIER)) {
return getExternalPackage(env,packageLookupValue.getRoot());
}
SkyKey externalPackageKey=PackageValue.key(Package.EXTERNAL_PACKAGE_IDENTIFIER);
PackageValue externalPackage=(PackageValue)env.getValue(externalPackageKey);
if (externalPackage == null) {
return null;
}
Package externalPkg=externalPackage.getPackage();
if (externalPkg.containsErrors()) {
throw new PackageFunctionException(new BuildFileContainsErrorsException(Package.EXTERNAL_PACKAGE_IDENTIFIER),Transience.PERSISTENT);
}
PathFragment buildFileFragment=packageNameFragment.getChild("BUILD");
RootedPath buildFileRootedPath=RootedPath.toRootedPath(packageLookupValue.getRoot(),buildFileFragment);
FileValue buildFileValue=null;
Path buildFilePath=buildFileRootedPath.asPath();
String replacementContents=null;
if (!isDefaultsPackage(packageId)) {
buildFileValue=getBuildFileValue(env,buildFileRootedPath);
if (buildFileValue == null) {
return null;
}
}
 else {
replacementContents=PrecomputedValue.DEFAULTS_PACKAGE_CONTENTS.get(env);
if (replacementContents == null) {
return null;
}
}
RuleVisibility defaultVisibility=PrecomputedValue.DEFAULT_VISIBILITY.get(env);
if (defaultVisibility == null) {
return null;
}
ASTFileLookupValue astLookupValue=null;
SkyKey astLookupKey=ASTFileLookupValue.key(PackageIdentifier.createInDefaultRepo(preludePath));
try {
astLookupValue=(ASTFileLookupValue)env.getValueOrThrow(astLookupKey,ErrorReadingSkylarkExtensionException.class,InconsistentFilesystemException.class);
}
 catch (ErrorReadingSkylarkExtensionException|InconsistentFilesystemException e) {
throw new PackageFunctionException(new BadPreludeFileException(packageId,e.getMessage()),Transience.PERSISTENT);
}
if (astLookupValue == null) {
return null;
}
List<Statement> preludeStatements=astLookupValue.getAST() == null ? ImmutableList.<Statement>of() : astLookupValue.getAST().getStatements();
Package.LegacyBuilder legacyPkgBuilder=loadPackage(externalPkg,replacementContents,packageId,buildFilePath,buildFileValue,buildFileFragment,defaultVisibility,preludeStatements,env);
if (legacyPkgBuilder == null) {
return null;
}
legacyPkgBuilder.buildPartial();
try {
handleLabelsCrossingSubpackagesAndPropagateInconsistentFilesystemExceptions(packageLookupValue.getRoot(),packageId,legacyPkgBuilder,env);
}
 catch (InternalInconsistentFilesystemException e) {
packageFunctionCache.invalidate(packageId);
throw new PackageFunctionException(e,e.isTransient() ? Transience.TRANSIENT : Transience.PERSISTENT);
}
Collection<Pair<String,Boolean>> globPatterns=legacyPkgBuilder.getGlobPatterns();
Map<Label,Path> subincludes=legacyPkgBuilder.getSubincludes();
boolean packageShouldBeConsideredInError;
try {
packageShouldBeConsideredInError=markDependenciesAndPropagateInconsistentFilesystemExceptions(env,globPatterns,subincludes,packageId,legacyPkgBuilder.containsErrors());
}
 catch (InternalInconsistentFilesystemException e) {
packageFunctionCache.invalidate(packageId);
throw new PackageFunctionException(e,e.isTransient() ? Transience.TRANSIENT : Transience.PERSISTENT);
}
if (env.valuesMissing()) {
return null;
}
Event.replayEventsOn(env.getListener(),legacyPkgBuilder.getEvents());
if (packageShouldBeConsideredInError) {
legacyPkgBuilder.setContainsErrors();
}
Package pkg=legacyPkgBuilder.finishBuild();
packageFunctionCache.invalidate(packageId);
return new PackageValue(pkg);
}
