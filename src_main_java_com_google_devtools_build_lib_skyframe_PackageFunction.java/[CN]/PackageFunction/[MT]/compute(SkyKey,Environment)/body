{
  PackageIdentifier packageId=(PackageIdentifier)key.argument();
  PathFragment packageNameFragment=packageId.getPackageFragment();
  String packageName=packageNameFragment.getPathString();
  SkyKey packageLookupKey=PackageLookupValue.key(packageId);
  PackageLookupValue packageLookupValue;
  try {
    packageLookupValue=(PackageLookupValue)env.getValueOrThrow(packageLookupKey,BuildFileNotFoundException.class,InconsistentFilesystemException.class);
  }
 catch (  BuildFileNotFoundException e) {
    throw new PackageFunctionException(e,Transience.PERSISTENT);
  }
catch (  InconsistentFilesystemException e) {
    throw new PackageFunctionException(new InternalInconsistentFilesystemException(packageId,e),Transience.PERSISTENT);
  }
  if (packageLookupValue == null) {
    return null;
  }
  if (!packageLookupValue.packageExists()) {
switch (packageLookupValue.getErrorReason()) {
case NO_BUILD_FILE:
case DELETED_PACKAGE:
case NO_EXTERNAL_PACKAGE:
      throw new PackageFunctionException(new BuildFileNotFoundException(packageId,packageLookupValue.getErrorMsg()),Transience.PERSISTENT);
case INVALID_PACKAGE_NAME:
    throw new PackageFunctionException(new InvalidPackageNameException(packageId,packageLookupValue.getErrorMsg()),Transience.PERSISTENT);
default :
  throw new IllegalStateException();
}
}
if (packageId.equals(Package.EXTERNAL_PACKAGE_IDENTIFIER)) {
return getExternalPackage(env,packageLookupValue.getRoot());
}
SkyKey externalPackageKey=PackageValue.key(Package.EXTERNAL_PACKAGE_IDENTIFIER);
PackageValue externalPackage=(PackageValue)env.getValue(externalPackageKey);
if (externalPackage == null) {
return null;
}
Package externalPkg=externalPackage.getPackage();
if (externalPkg.containsErrors()) {
throw new PackageFunctionException(new BuildFileContainsErrorsException(Package.EXTERNAL_PACKAGE_IDENTIFIER),Transience.PERSISTENT);
}
PathFragment buildFileFragment=packageNameFragment.getChild("BUILD");
RootedPath buildFileRootedPath=RootedPath.toRootedPath(packageLookupValue.getRoot(),buildFileFragment);
FileValue buildFileValue;
try {
buildFileValue=(FileValue)env.getValueOrThrow(FileValue.key(buildFileRootedPath),IOException.class,FileSymlinkException.class,InconsistentFilesystemException.class);
}
 catch (IOException|FileSymlinkException|InconsistentFilesystemException e) {
throw new IllegalStateException("Package lookup succeeded but encountered error when " + "getting FileValue for BUILD file directly.",e);
}
if (buildFileValue == null) {
return null;
}
Preconditions.checkState(buildFileValue.exists(),"Package lookup succeeded but BUILD file doesn't exist");
Path buildFilePath=buildFileRootedPath.asPath();
String replacementContents=null;
if (packageName.equals(DEFAULTS_PACKAGE_NAME) && packageId.getRepository().isDefault()) {
replacementContents=PrecomputedValue.DEFAULTS_PACKAGE_CONTENTS.get(env);
if (replacementContents == null) {
return null;
}
}
RuleVisibility defaultVisibility=PrecomputedValue.DEFAULT_VISIBILITY.get(env);
if (defaultVisibility == null) {
return null;
}
ASTFileLookupValue astLookupValue=null;
SkyKey astLookupKey=ASTFileLookupValue.key(PackageIdentifier.createInDefaultRepo(preludePath));
try {
astLookupValue=(ASTFileLookupValue)env.getValueOrThrow(astLookupKey,ErrorReadingSkylarkExtensionException.class,InconsistentFilesystemException.class);
}
 catch (ErrorReadingSkylarkExtensionException|InconsistentFilesystemException e) {
throw new PackageFunctionException(new BadPreludeFileException(packageId,e.getMessage()),Transience.PERSISTENT);
}
if (astLookupValue == null) {
return null;
}
List<Statement> preludeStatements=astLookupValue.getAST() == null ? ImmutableList.<Statement>of() : astLookupValue.getAST().getStatements();
ParserInputSource inputSource;
try {
if (showLoadingProgress.get() && packageFunctionCache.getIfPresent(packageId) == null) {
env.getListener().handle(Event.progress("Loading package: " + packageName));
}
inputSource=ParserInputSource.create(buildFilePath,buildFileValue.getSize());
}
 catch (IOException e) {
env.getListener().handle(Event.error(Location.fromFile(buildFilePath),e.getMessage()));
throw new PackageFunctionException(new BuildFileContainsErrorsException(packageId,e.getMessage()),Transience.TRANSIENT);
}
Package.LegacyBuilder legacyPkgBuilder=loadPackage(externalPkg,inputSource,replacementContents,packageId,buildFilePath,buildFileFragment,defaultVisibility,preludeStatements,env);
if (legacyPkgBuilder == null) {
return null;
}
legacyPkgBuilder.buildPartial();
try {
handleLabelsCrossingSubpackagesAndPropagateInconsistentFilesystemExceptions(packageLookupValue.getRoot(),packageId,legacyPkgBuilder,env);
}
 catch (InternalInconsistentFilesystemException e) {
packageFunctionCache.invalidate(packageId);
throw new PackageFunctionException(e,e.isTransient() ? Transience.TRANSIENT : Transience.PERSISTENT);
}
if (env.valuesMissing()) {
return null;
}
Collection<Pair<String,Boolean>> globPatterns=legacyPkgBuilder.getGlobPatterns();
Map<Label,Path> subincludes=legacyPkgBuilder.getSubincludes();
Event.replayEventsOn(env.getListener(),legacyPkgBuilder.getEvents());
boolean packageShouldBeConsideredInError;
try {
packageShouldBeConsideredInError=markDependenciesAndPropagateInconsistentFilesystemExceptions(env,globPatterns,subincludes,packageId,legacyPkgBuilder.containsErrors());
}
 catch (InternalInconsistentFilesystemException e) {
packageFunctionCache.invalidate(packageId);
throw new PackageFunctionException(e,e.isTransient() ? Transience.TRANSIENT : Transience.PERSISTENT);
}
if (env.valuesMissing()) {
return null;
}
if (packageShouldBeConsideredInError) {
legacyPkgBuilder.setContainsErrors();
}
Package pkg=legacyPkgBuilder.finishBuild();
packageFunctionCache.invalidate(packageId);
return new PackageValue(pkg);
}
