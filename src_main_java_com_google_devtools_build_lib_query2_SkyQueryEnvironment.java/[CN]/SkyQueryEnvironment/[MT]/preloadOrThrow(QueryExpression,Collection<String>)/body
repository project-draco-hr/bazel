{
  GraphBackedRecursivePackageProvider provider=new GraphBackedRecursivePackageProvider(graph,universeTargetPatternKeys,pkgPath);
  Map<String,Set<Target>> result=Maps.newHashMapWithExpectedSize(patterns.size());
  Map<String,SkyKey> keys=new HashMap<>(patterns.size());
  for (  String pattern : patterns) {
    keys.put(pattern,TargetPatternValue.key(pattern,TargetPatternEvaluator.DEFAULT_FILTERING_POLICY,parserPrefix));
  }
  Map<SkyKey,SkyValue> existingPatterns=graph.getSuccessfulValues(keys.values());
  Map<String,Set<Target>> patternsWithTargetsToFilter=new HashMap<>();
  for (  String pattern : patterns) {
    SkyKey patternKey=keys.get(pattern);
    TargetParsingException targetParsingException=null;
    if (existingPatterns.containsKey(patternKey)) {
      TargetPatternValue value=(TargetPatternValue)existingPatterns.get(patternKey);
      if (value != null) {
        result.put(pattern,ImmutableSet.copyOf(makeTargetsFromLabels(value.getTargets().getTargets())));
      }
 else {
        targetParsingException=(TargetParsingException)Preconditions.checkNotNull(graph.getException(patternKey),pattern);
      }
    }
 else {
      TargetPatternValue.TargetPatternKey targetPatternKey=((TargetPatternValue.TargetPatternKey)patternKey.argument());
      RecursivePackageProviderBackedTargetPatternResolver resolver=new RecursivePackageProviderBackedTargetPatternResolver(provider,eventHandler,targetPatternKey.getPolicy());
      TargetPattern parsedPattern=targetPatternKey.getParsedPattern();
      try {
        patternsWithTargetsToFilter.put(pattern,parsedPattern.eval(resolver).getTargets());
      }
 catch (      TargetParsingException e) {
        targetParsingException=e;
      }
catch (      InterruptedException e) {
        throw new QueryException(e.getMessage());
      }
    }
    if (targetParsingException != null) {
      if (!keepGoing) {
        throw targetParsingException;
      }
 else {
        eventHandler.handle(Event.error("Evaluation of query \"" + caller + "\" failed: "+ targetParsingException.getMessage()));
        result.put(pattern,ImmutableSet.<Target>of());
      }
    }
  }
  Set<Target> targetsInGraph=filterTargetsNotInGraph(ImmutableSet.copyOf(Iterables.concat(patternsWithTargetsToFilter.values())));
  for (  Entry<String,Set<Target>> pattern : patternsWithTargetsToFilter.entrySet()) {
    result.put(pattern.getKey(),Sets.intersection(pattern.getValue(),targetsInGraph));
  }
  return result;
}
