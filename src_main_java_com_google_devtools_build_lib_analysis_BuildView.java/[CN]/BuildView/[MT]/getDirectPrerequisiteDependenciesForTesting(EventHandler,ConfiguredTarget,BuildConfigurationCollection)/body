{
  if (!(ct.getTarget() instanceof Rule)) {
    return ArrayListMultimap.create();
  }
class SilentDependencyResolver extends DependencyResolver {
    @Override protected void invalidVisibilityReferenceHook(    TargetAndConfiguration node,    Label label){
      throw new RuntimeException("bad visibility on " + label + " during testing unexpected");
    }
    @Override protected void invalidPackageGroupReferenceHook(    TargetAndConfiguration node,    Label label){
      throw new RuntimeException("bad package group on " + label + " during testing unexpected");
    }
    @Override protected void missingEdgeHook(    Target from,    Label to,    NoSuchThingException e){
      throw new RuntimeException("missing dependency from " + from.getLabel() + " to "+ to+ ": "+ e.getMessage(),e);
    }
    @Override protected Target getTarget(    Target from,    Label label,    NestedSetBuilder<Label> rootCauses){
      try {
        return LoadedPackageProvider.Bridge.getLoadedTarget(skyframeExecutor.getPackageManager(),eventHandler,label);
      }
 catch (      NoSuchThingException e) {
        throw new IllegalStateException(e);
      }
    }
  }
  DependencyResolver dependencyResolver=new SilentDependencyResolver();
  TargetAndConfiguration ctgNode=new TargetAndConfiguration(ct.getTarget(),ct.getConfiguration());
  return dependencyResolver.dependentNodeMap(ctgNode,configurations.getHostConfiguration(),null,getConfigurableAttributeKeysForTesting(eventHandler,ctgNode));
}
