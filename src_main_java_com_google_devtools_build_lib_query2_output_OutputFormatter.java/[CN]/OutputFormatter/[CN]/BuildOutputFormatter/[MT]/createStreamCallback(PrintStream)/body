{
  return new OutputFormatterCallback<Target>(){
    private final Set<Label> printed=CompactHashSet.create();
    private void outputRule(    Rule rule,    PrintStream out){
      out.printf("# %s%n",rule.getLocation());
      out.printf("%s(%n",rule.getRuleClass());
      out.printf("  name = \"%s\",%n",rule.getName());
      for (      Attribute attr : rule.getAttributes()) {
        Pair<Iterable<Object>,AttributeValueSource> values=getPossibleAttributeValuesAndSources(rule,attr);
        if (Iterables.size(values.first) != 1) {
          continue;
        }
        if (values.second != AttributeValueSource.RULE) {
          continue;
        }
        Object value=Iterables.getOnlyElement(values.first);
        out.printf("  %s = ",attr.getPublicName());
        if (value instanceof Label) {
          value=((Label)value).getDefaultCanonicalForm();
        }
 else         if (value instanceof License) {
          List<String> licenseTypes=new ArrayList<String>();
          for (          License.LicenseType licenseType : ((License)value).getLicenseTypes()) {
            licenseTypes.add(licenseType.toString().toLowerCase());
          }
          value=licenseTypes;
        }
 else         if (value instanceof List<?> && EvalUtils.isImmutable(value)) {
          value=new ArrayList<>((List<?>)value);
        }
        StringBuilder builder=new StringBuilder();
        Printer.write(builder,value);
        out.print(builder);
        out.println(",");
      }
      out.printf(")\n%n");
    }
    @Override protected void processOutput(    Iterable<Target> partialResult) throws IOException, InterruptedException {
      for (      Target target : partialResult) {
        Rule rule=target.getAssociatedRule();
        if (rule == null || printed.contains(rule.getLabel())) {
          continue;
        }
        outputRule(rule,out);
        printed.add(rule.getLabel());
      }
    }
  }
;
}
