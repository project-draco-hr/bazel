{
  Attribute.Builder<?> builder=Attribute.attr("",type);
  Object defaultValue=arguments.get(DEFAULT_ARG);
  if (!EvalUtils.isNullOrNone(defaultValue)) {
    if (defaultValue instanceof UserDefinedFunction) {
      builder.value(new SkylarkLateBound(new SkylarkCallbackFunction((UserDefinedFunction)defaultValue,ast,env)));
    }
 else {
      builder.defaultValue(defaultValue);
    }
  }
  for (  String flag : SkylarkList.castSkylarkListOrNoneToList(arguments.get(FLAGS_ARG),String.class,FLAGS_ARG)) {
    builder.setPropertyFlag(flag);
  }
  if (containsNonNoneKey(arguments,MANDATORY_ARG) && (Boolean)arguments.get(MANDATORY_ARG)) {
    builder.setPropertyFlag("MANDATORY");
  }
  if (containsNonNoneKey(arguments,NON_EMPTY_ARG) && (Boolean)arguments.get(NON_EMPTY_ARG)) {
    builder.setPropertyFlag("NON_EMPTY");
  }
  if (containsNonNoneKey(arguments,EXECUTABLE_ARG) && (Boolean)arguments.get(EXECUTABLE_ARG)) {
    builder.setPropertyFlag("EXECUTABLE");
  }
  if (containsNonNoneKey(arguments,SINGLE_FILE_ARG) && (Boolean)arguments.get(SINGLE_FILE_ARG)) {
    builder.setPropertyFlag("SINGLE_ARTIFACT");
  }
  if (containsNonNoneKey(arguments,ALLOW_FILES_ARG)) {
    Object fileTypesObj=arguments.get(ALLOW_FILES_ARG);
    if (fileTypesObj == Boolean.TRUE) {
      builder.allowedFileTypes(FileTypeSet.ANY_FILE);
    }
 else     if (fileTypesObj == Boolean.FALSE) {
      builder.allowedFileTypes(FileTypeSet.NO_FILE);
    }
 else     if (fileTypesObj instanceof SkylarkFileType) {
      builder.allowedFileTypes(((SkylarkFileType)fileTypesObj).getFileTypeSet());
    }
 else     if (fileTypesObj instanceof SkylarkList) {
      List<String> arg=SkylarkList.castSkylarkListOrNoneToList(fileTypesObj,String.class,"allow_files argument");
      builder.allowedFileTypes(FileType.of(arg));
    }
 else {
      throw new EvalException(ast.getLocation(),"allow_files should be a boolean or a string list");
    }
  }
 else   if (type.equals(BuildType.LABEL) || type.equals(BuildType.LABEL_LIST)) {
    builder.allowedFileTypes(FileTypeSet.NO_FILE);
  }
  Object ruleClassesObj=arguments.get(ALLOW_RULES_ARG);
  if (ruleClassesObj != null && ruleClassesObj != Runtime.NONE) {
    builder.allowedRuleClasses(SkylarkList.castSkylarkListOrNoneToList(ruleClassesObj,String.class,"allowed rule classes for attribute definition"));
  }
  List<Object> values=SkylarkList.castSkylarkListOrNoneToList(arguments.get(VALUES_ARG),Object.class,VALUES_ARG);
  if (!Iterables.isEmpty(values)) {
    builder.allowedValues(new AllowedValueSet(values));
  }
  if (containsNonNoneKey(arguments,PROVIDERS_ARG)) {
    Object obj=arguments.get(PROVIDERS_ARG);
    SkylarkType.checkType(obj,SkylarkList.class,PROVIDERS_ARG);
    boolean isSingleListOfStr=true;
    for (    Object o : (SkylarkList)obj) {
      isSingleListOfStr=o instanceof String;
      if (!isSingleListOfStr) {
        break;
      }
    }
    if (isSingleListOfStr) {
      builder.mandatoryProviders(((SkylarkList<?>)obj).getContents(String.class,PROVIDERS_ARG));
    }
 else {
      builder.mandatoryProvidersList(getProvidersList((SkylarkList)obj));
    }
  }
  if (containsNonNoneKey(arguments,CONFIGURATION_ARG)) {
    Object trans=arguments.get(CONFIGURATION_ARG);
    if (trans instanceof ConfigurationTransition) {
      builder.cfg((ConfigurationTransition)trans);
    }
 else     if (trans.equals("data")) {
      builder.cfg(ConfigurationTransition.DATA);
    }
 else     if (trans.equals("host")) {
      builder.cfg(ConfigurationTransition.HOST);
    }
 else {
      throw new EvalException(ast.getLocation(),"cfg must be either 'data' or 'host'.");
    }
  }
  return builder;
}
