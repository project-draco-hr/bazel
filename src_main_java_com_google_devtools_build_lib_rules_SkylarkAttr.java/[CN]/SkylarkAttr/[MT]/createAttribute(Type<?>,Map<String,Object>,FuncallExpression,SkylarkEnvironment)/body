{
  Attribute.Builder<?> builder=Attribute.attr("",type);
  Object defaultValue=arguments.get(DEFAULT_ARG);
  if (!EvalUtils.isNullOrNone(defaultValue)) {
    if (defaultValue instanceof UserDefinedFunction) {
      builder.value(new SkylarkLateBound(new SkylarkCallbackFunction((UserDefinedFunction)defaultValue,ast,env)));
    }
 else {
      builder.defaultValue(defaultValue);
    }
  }
  for (  String flag : castList(arguments.get(FLAGS_ARG),String.class)) {
    builder.setPropertyFlag(flag);
  }
  if (containsNonNoneKey(arguments,MANDATORY_ARG) && (Boolean)arguments.get(MANDATORY_ARG)) {
    builder.setPropertyFlag("MANDATORY");
  }
  if (containsNonNoneKey(arguments,NON_EMPTY_ARG) && (Boolean)arguments.get(NON_EMPTY_ARG)) {
    builder.setPropertyFlag("NON_EMPTY");
  }
  if (containsNonNoneKey(arguments,EXECUTABLE_ARG) && (Boolean)arguments.get(EXECUTABLE_ARG)) {
    builder.setPropertyFlag("EXECUTABLE");
  }
  if (containsNonNoneKey(arguments,SINGLE_FILE_ARG) && (Boolean)arguments.get(SINGLE_FILE_ARG)) {
    builder.setPropertyFlag("SINGLE_ARTIFACT");
  }
  if (containsNonNoneKey(arguments,ALLOW_FILES_ARG)) {
    Object fileTypesObj=arguments.get(ALLOW_FILES_ARG);
    if (fileTypesObj == Boolean.TRUE) {
      builder.allowedFileTypes(FileTypeSet.ANY_FILE);
    }
 else     if (fileTypesObj == Boolean.FALSE) {
      builder.allowedFileTypes(FileTypeSet.NO_FILE);
    }
 else     if (fileTypesObj instanceof SkylarkFileType) {
      builder.allowedFileTypes(((SkylarkFileType)fileTypesObj).getFileTypeSet());
    }
 else {
      throw new EvalException(ast.getLocation(),"allow_files should be a boolean or a filetype object.");
    }
  }
 else   if (type.equals(Type.LABEL) || type.equals(Type.LABEL_LIST)) {
    builder.allowedFileTypes(FileTypeSet.NO_FILE);
  }
  Object ruleClassesObj=arguments.get(ALLOW_RULES_ARG);
  if (ruleClassesObj != null && ruleClassesObj != Environment.NONE) {
    builder.allowedRuleClasses(castList(ruleClassesObj,String.class,"allowed rule classes for attribute definition"));
  }
  Iterable<Object> values=castList(arguments.get(VALUES_ARG),Object.class);
  if (!Iterables.isEmpty(values)) {
    builder.allowedValues(new AllowedValueSet(values));
  }
  if (containsNonNoneKey(arguments,PROVIDERS_ARG)) {
    builder.mandatoryProviders(castList(arguments.get(PROVIDERS_ARG),String.class));
  }
  if (containsNonNoneKey(arguments,CONFIGURATION_ARG)) {
    builder.cfg((ConfigurationTransition)arguments.get(CONFIGURATION_ARG));
  }
  return builder;
}
