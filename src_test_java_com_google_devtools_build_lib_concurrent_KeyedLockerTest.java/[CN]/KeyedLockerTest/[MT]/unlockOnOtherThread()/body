{
  final AtomicReference<AutoUnlocker> unlockerRef=new AtomicReference<>();
  final CountDownLatch unlockerRefSetLatch=new CountDownLatch(1);
  final AtomicBoolean runnableInterrupted=new AtomicBoolean(false);
  final AtomicBoolean runnable2Executed=new AtomicBoolean(false);
  Runnable runnable1=new Runnable(){
    @Override public void run(){
      unlockerRef.set(locker.lock("cat"));
      unlockerRefSetLatch.countDown();
    }
  }
;
  Runnable runnable2=new Runnable(){
    @Override public void run(){
      try {
        unlockerRefSetLatch.await(TestUtils.WAIT_TIMEOUT_SECONDS,TimeUnit.SECONDS);
      }
 catch (      InterruptedException e) {
        runnableInterrupted.set(true);
      }
      try {
        Preconditions.checkNotNull(unlockerRef.get()).close();
        fail();
      }
 catch (      IllegalStateException e) {
        String expectedMessage="the calling thread must be the one that acquired the " + "AutoUnlocker";
        assertThat(e.getMessage()).contains(expectedMessage);
        runnable2Executed.set(true);
      }
    }
  }
;
  executorService.submit(runnable1);
  executorService.submit(runnable2);
  boolean interrupted=ExecutorShutdownUtil.interruptibleShutdown(executorService);
  if (interrupted || runnableInterrupted.get()) {
    Thread.currentThread().interrupt();
    throw new InterruptedException();
  }
  assertTrue(runnable2Executed.get());
}
