"Adds support for parameterized tests to Python's unittest TestCase class.\n\nA parameterized test is a method in a test case that is invoked with different\nargument tuples.\n\nA simple example:\n\n  class AdditionExample(parameterized.ParameterizedTestCase):\n    @parameterized.Parameters(\n       (1, 2, 3),\n       (4, 5, 9),\n       (1, 1, 3))\n    def testAddition(self, op1, op2, result):\n      self.assertEqual(result, op1 + op2)\n\n\nEach invocation is a separate test case and properly isolated just\nlike a normal test method, with its own setUp/tearDown cycle. In the\nexample above, there are three separate testcases, one of which will\nfail due to an assertion error (1 + 1 != 3).\n\nParameters for invididual test cases can be tuples (with positional parameters)\nor dictionaries (with named parameters):\n\n  class AdditionExample(parameterized.ParameterizedTestCase):\n    @parameterized.Parameters(\n       {'op1': 1, 'op2': 2, 'result': 3},\n       {'op1': 4, 'op2': 5, 'result': 9},\n    )\n    def testAddition(self, op1, op2, result):\n      self.assertEqual(result, op1 + op2)\n\nIf a parameterized test fails, the error message will show the\noriginal test name (which is modified internally) and the arguments\nfor the specific invocation, which are part of the string returned by\nthe shortDescription() method on test cases.\n\nThe id method of the test, used internally by the unittest framework,\nis also modified to show the arguments. To make sure that test names\nstay the same across several invocations, object representations like\n\n  >>> class Foo(object):\n  ...  pass\n  >>> repr(Foo())\n  '<__main__.Foo object at 0x23d8610>'\n\nare turned into '<__main__.Foo>'. For even more descriptive names,\nespecially in test logs, you can use the NamedParameters decorator. In\nthis case, only tuples are supported, and the first parameters has to\nbe a string (or an object that returns an apt name when converted via\nstr()):\n\n  class NamedExample(parameterized.ParameterizedTestCase):\n    @parameterized.NamedParameters(\n       ('Normal', 'aa', 'aaa', True),\n       ('EmptyPrefix', '', 'abc', True),\n       ('BothEmpty', '', '', True))\n    def testStartsWith(self, prefix, string, result):\n      self.assertEqual(result, strings.startswith(prefix))\n\nNamed tests also have the benefit that they can be run individually\nfrom the command line:\n\n  $ testmodule.py NamedExample.testStartsWithNormal\n  .\n  --------------------------------------------------------------------\n  Ran 1 test in 0.000s\n\n  OK\n\nParameterized Classes\n=====================\nIf invocation arguments are shared across test methods in a single\nParameterizedTestCase class, instead of decorating all test methods\nindividually, the class itself can be decorated:\n\n  @parameterized.Parameters(\n    (1, 2, 3)\n    (4, 5, 9))\n  class ArithmeticTest(parameterized.ParameterizedTestCase):\n    def testAdd(self, arg1, arg2, result):\n      self.assertEqual(arg1 + arg2, result)\n\n    def testSubtract(self, arg2, arg2, result):\n      self.assertEqual(result - arg1, arg2)\n\nInputs from Iterables\n=====================\nIf parameters should be shared across several test cases, or are dynamically\ncreated from other sources, a single non-tuple iterable can be passed into\nthe decorator. This iterable will be used to obtain the test cases:\n\n  class AdditionExample(parameterized.ParameterizedTestCase):\n    @parameterized.Parameters(\n      c.op1, c.op2, c.result for c in testcases\n    )\n    def testAddition(self, op1, op2, result):\n      self.assertEqual(result, op1 + op2)\n\n\nSingle-Argument Test Methods\n============================\nIf a test method takes only one argument, the single argument does not need to\nbe wrapped into a tuple:\n\n  class NegativeNumberExample(parameterized.ParameterizedTestCase):\n    @parameterized.Parameters(\n       -1, -3, -4, -5\n    )\n    def testIsNegative(self, arg):\n      self.assertTrue(IsNegative(arg))\n"
__author__ = 'tmarek@google.com (Torsten Marek)'
import collections
import functools
import re
import types
try:
    import unittest2 as unittest
except ImportError:
    import unittest
import uuid
import six
ADDR_RE = re.compile('\\<([a-zA-Z0-9_\\-\\.]+) object at 0x[a-fA-F0-9]+\\>')
_SEPARATOR = uuid.uuid1().hex
_FIRST_ARG = object()
_ARGUMENT_REPR = object()
