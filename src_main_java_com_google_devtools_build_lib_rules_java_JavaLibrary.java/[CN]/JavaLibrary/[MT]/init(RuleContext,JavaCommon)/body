{
  common.initializeJavacOpts();
  JavaTargetAttributes.Builder attributesBuilder=common.initCommon();
  JavaCompilationHelper helper=new JavaCompilationHelper(ruleContext,semantics,common.getJavacOpts(),attributesBuilder);
  helper.addLibrariesToAttributes(common.targetsTreatedAsDeps(ClasspathType.COMPILE_ONLY));
  helper.addProvidersToAttributes(common.compilationArgsFromSources(),JavaCommon.isNeverLink(ruleContext));
  if (ruleContext.hasErrors()) {
    return null;
  }
  semantics.checkRule(ruleContext,common);
  JavaCompilationArtifacts.Builder javaArtifactsBuilder=new JavaCompilationArtifacts.Builder();
  if (ruleContext.hasErrors()) {
    common.setJavaCompilationArtifacts(JavaCompilationArtifacts.EMPTY);
    return null;
  }
  JavaConfiguration javaConfig=ruleContext.getFragment(JavaConfiguration.class);
  NestedSetBuilder<Artifact> filesBuilder=NestedSetBuilder.stableOrder();
  JavaTargetAttributes attributes=helper.getAttributes();
  if (attributes.hasJarFiles()) {
    Set<Artifact> jarFiles=attributes.getJarFiles();
    javaArtifactsBuilder.addRuntimeJars(jarFiles);
    javaArtifactsBuilder.addCompileTimeJars(attributes.getCompileTimeJarFiles());
    filesBuilder.addAll(jarFiles);
  }
  if (attributes.hasMessages()) {
    helper.addTranslations(semantics.translate(ruleContext,javaConfig,attributes.getMessages()));
  }
  ruleContext.checkSrcsSamePackage(true);
  Artifact jar=null;
  Artifact srcJar=ruleContext.getImplicitOutputArtifact(JavaSemantics.JAVA_LIBRARY_SOURCE_JAR);
  Artifact classJar=ruleContext.getImplicitOutputArtifact(JavaSemantics.JAVA_LIBRARY_CLASS_JAR);
  if (attributes.hasSourceFiles() || attributes.hasSourceJars() || attributes.hasResources()|| attributes.hasMessages()) {
    javaArtifactsBuilder.addRuntimeJar(classJar);
    jar=classJar;
  }
  filesBuilder.add(classJar);
  Artifact manifestProtoOutput=helper.createManifestProtoOutput(classJar);
  Artifact genSourceJar=null;
  Artifact genClassJar=null;
  if (helper.usesAnnotationProcessing()) {
    genClassJar=helper.createGenJar(classJar);
    genSourceJar=helper.createGensrcJar(classJar);
    helper.createGenJarAction(classJar,manifestProtoOutput,genClassJar);
  }
  Artifact outputDepsProto=helper.createOutputDepsProtoArtifact(classJar,javaArtifactsBuilder);
  helper.createCompileActionWithInstrumentation(classJar,manifestProtoOutput,genSourceJar,outputDepsProto,javaArtifactsBuilder);
  helper.createSourceJarAction(srcJar,genSourceJar);
  if ((attributes.hasSourceFiles() || attributes.hasSourceJars()) && jar != null) {
    helper.createCompileTimeJarAction(jar,outputDepsProto,javaArtifactsBuilder);
  }
  boolean neverLink=JavaCommon.isNeverLink(ruleContext);
  common.setJavaCompilationArtifacts(javaArtifactsBuilder.build());
  common.setClassPathFragment(new ClasspathConfiguredFragment(common.getJavaCompilationArtifacts(),attributes,neverLink));
  CppCompilationContext transitiveCppDeps=common.collectTransitiveCppDeps();
  NestedSet<Artifact> transitiveSourceJars=common.collectTransitiveSourceJars(srcJar);
  JavaCompilationArgs javaCompilationArgs=common.collectJavaCompilationArgs(false,neverLink,common.compilationArgsFromSources());
  JavaCompilationArgs recursiveJavaCompilationArgs=common.collectJavaCompilationArgs(true,neverLink,common.compilationArgsFromSources());
  NestedSet<Artifact> compileTimeJavaDepArtifacts=common.collectCompileTimeDependencyArtifacts(common.getJavaCompilationArtifacts().getCompileTimeDependencyArtifact());
  NestedSet<Artifact> runTimeJavaDepArtifacts=NestedSetBuilder.emptySet(Order.STABLE_ORDER);
  NestedSet<LinkerInput> transitiveJavaNativeLibraries=common.collectTransitiveJavaNativeLibraries();
  ImmutableList<String> exportedProcessorClasses=ImmutableList.of();
  NestedSet<Artifact> exportedProcessorClasspath=NestedSetBuilder.emptySet(Order.NAIVE_LINK_ORDER);
  ImmutableList.Builder<String> processorClasses=ImmutableList.builder();
  NestedSetBuilder<Artifact> processorClasspath=NestedSetBuilder.naiveLinkOrder();
  for (  JavaPluginInfoProvider provider : Iterables.concat(common.getPluginInfoProvidersForAttribute("exported_plugins",Mode.HOST),common.getPluginInfoProvidersForAttribute("exports",Mode.TARGET))) {
    processorClasses.addAll(provider.getProcessorClasses());
    processorClasspath.addTransitive(provider.getProcessorClasspath());
  }
  exportedProcessorClasses=processorClasses.build();
  exportedProcessorClasspath=processorClasspath.build();
  CcLinkParamsStore ccLinkParamsStore=new CcLinkParamsStore(){
    @Override protected void collect(    CcLinkParams.Builder builder,    boolean linkingStatically,    boolean linkShared){
      builder.addTransitiveTargets(common.targetsTreatedAsDeps(ClasspathType.BOTH),JavaCcLinkParamsProvider.TO_LINK_PARAMS,CcLinkParamsProvider.TO_LINK_PARAMS);
    }
  }
;
  Runfiles runfiles=Runfiles.EMPTY;
  if (!neverLink) {
    Runfiles.Builder runfilesBuilder=new Runfiles.Builder(ruleContext.getWorkspaceName()).addArtifacts(common.getJavaCompilationArtifacts().getRuntimeJars());
    runfilesBuilder.addRunfiles(ruleContext,RunfilesProvider.DEFAULT_RUNFILES);
    runfilesBuilder.add(ruleContext,JavaRunfilesProvider.TO_RUNFILES);
    List<TransitiveInfoCollection> depsForRunfiles=new ArrayList<>();
    if (ruleContext.getRule().isAttrDefined("runtime_deps",BuildType.LABEL_LIST)) {
      depsForRunfiles.addAll(ruleContext.getPrerequisites("runtime_deps",Mode.TARGET));
    }
    if (ruleContext.getRule().isAttrDefined("exports",BuildType.LABEL_LIST)) {
      depsForRunfiles.addAll(ruleContext.getPrerequisites("exports",Mode.TARGET));
    }
    runfilesBuilder.addTargets(depsForRunfiles,RunfilesProvider.DEFAULT_RUNFILES);
    runfilesBuilder.addTargets(depsForRunfiles,JavaRunfilesProvider.TO_RUNFILES);
    TransitiveInfoCollection launcher=JavaHelper.launcherForTarget(semantics,ruleContext);
    if (launcher != null) {
      runfilesBuilder.addTarget(launcher,RunfilesProvider.DATA_RUNFILES);
    }
    semantics.addRunfilesForLibrary(ruleContext,runfilesBuilder);
    runfiles=runfilesBuilder.build();
  }
  RuleConfiguredTargetBuilder builder=new RuleConfiguredTargetBuilder(ruleContext);
  semantics.addProviders(ruleContext,common,ImmutableList.<String>of(),classJar,srcJar,genClassJar,genSourceJar,ImmutableMap.<Artifact,Artifact>of(),helper,filesBuilder,builder);
  NestedSet<Artifact> filesToBuild=filesBuilder.build();
  common.addTransitiveInfoProviders(builder,filesToBuild,classJar);
  common.addGenJarsProvider(builder,genClassJar,genSourceJar);
  builder.add(JavaRuleOutputJarsProvider.class,new JavaRuleOutputJarsProvider(classJar,srcJar)).add(JavaRuntimeJarProvider.class,new JavaRuntimeJarProvider(common.getJavaCompilationArtifacts().getRuntimeJars())).add(RunfilesProvider.class,RunfilesProvider.simple(runfiles)).setFilesToBuild(filesToBuild).addSkylarkTransitiveInfo(JavaSkylarkApiProvider.NAME,new JavaSkylarkApiProvider()).add(JavaNeverlinkInfoProvider.class,new JavaNeverlinkInfoProvider(neverLink)).add(CppCompilationContext.class,transitiveCppDeps).add(JavaCompilationArgsProvider.class,new JavaCompilationArgsProvider(javaCompilationArgs,recursiveJavaCompilationArgs,compileTimeJavaDepArtifacts,runTimeJavaDepArtifacts)).add(CcLinkParamsProvider.class,new CcLinkParamsProvider(ccLinkParamsStore)).add(JavaNativeLibraryProvider.class,new JavaNativeLibraryProvider(transitiveJavaNativeLibraries)).add(JavaSourceInfoProvider.class,JavaSourceInfoProvider.fromJavaTargetAttributes(attributes,semantics)).add(JavaSourceJarsProvider.class,new JavaSourceJarsProvider(transitiveSourceJars,ImmutableList.of(srcJar))).add(JavaPluginInfoProvider.class,new JavaPluginInfoProvider(exportedProcessorClasses,exportedProcessorClasspath)).addOutputGroup(JavaSemantics.SOURCE_JARS_OUTPUT_GROUP,transitiveSourceJars);
  if (ruleContext.hasErrors()) {
    return null;
  }
  return builder;
}
