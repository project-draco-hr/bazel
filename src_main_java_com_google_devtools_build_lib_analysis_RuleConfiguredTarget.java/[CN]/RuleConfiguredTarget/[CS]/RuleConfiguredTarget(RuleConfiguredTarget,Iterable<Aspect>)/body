{
  super(base.getTarget(),base.getConfiguration());
  Set<Class<? extends TransitiveInfoProvider>> providers=new HashSet<>();
  providers.addAll(base.providers.keySet());
  OutputGroupProvider baseOutputGroupProvider=base.getProvider(OutputGroupProvider.class);
  List<OutputGroupProvider> outputGroupProviders=new ArrayList<>();
  if (baseOutputGroupProvider != null) {
    outputGroupProviders.add(baseOutputGroupProvider);
  }
  for (  Aspect aspect : aspects) {
    final OutputGroupProvider aspectProvider=aspect.getProvider(OutputGroupProvider.class);
    if (aspectProvider == null) {
      continue;
    }
    outputGroupProviders.add(aspectProvider);
  }
  OutputGroupProvider outputGroupProvider=OutputGroupProvider.merge(outputGroupProviders);
  for (  Aspect aspect : aspects) {
    for (    TransitiveInfoProvider aspectProvider : aspect) {
      Class<? extends TransitiveInfoProvider> aClass=aspectProvider.getClass();
      if (OutputGroupProvider.class.equals(aClass)) {
        continue;
      }
      if (!providers.add(aClass)) {
        throw new IllegalStateException("Provider " + aClass + " provided twice");
      }
    }
  }
  if (baseOutputGroupProvider == outputGroupProvider) {
    this.providers=base.providers;
  }
 else {
    ImmutableMap.Builder<Class<? extends TransitiveInfoProvider>,Object> builder=new ImmutableMap.Builder<>();
    for (    Class<? extends TransitiveInfoProvider> aClass : base.providers.keySet()) {
      if (OutputGroupProvider.class.equals(aClass)) {
        continue;
      }
      builder.put(aClass,base.providers.get(aClass));
    }
    builder.put(OutputGroupProvider.class,outputGroupProvider);
    this.providers=builder.build();
  }
  this.mandatoryStampFiles=base.mandatoryStampFiles;
  this.configConditions=base.configConditions;
  this.aspects=ImmutableList.copyOf(aspects);
}
