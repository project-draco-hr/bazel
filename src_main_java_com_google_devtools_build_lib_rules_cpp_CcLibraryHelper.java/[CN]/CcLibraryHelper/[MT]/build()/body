{
  Preconditions.checkState(ruleContext.getRule().getRuleClass().equals("cc_inc_library") || ruleContext.getRule().isAttrDefined(":lipo_context_collector",BuildType.LABEL));
  if (checkDepsGenerateCpp) {
    for (    LanguageDependentFragment dep : AnalysisUtils.getProviders(deps,LanguageDependentFragment.class)) {
      LanguageDependentFragment.Checker.depSupportsLanguage(ruleContext,dep,CppRuleClasses.LANGUAGE);
    }
  }
  CppModel model=initializeCppModel();
  CppCompilationContext cppCompilationContext=initializeCppCompilationContext(model);
  model.setContext(cppCompilationContext);
  boolean compileHeaderModules=featureConfiguration.isEnabled(CppRuleClasses.HEADER_MODULES);
  Preconditions.checkState(!compileHeaderModules || cppCompilationContext.getCppModuleMap() != null,"All cc rules must support module maps.");
  CcCompilationOutputs ccOutputs=model.createCcCompileActions();
  if (!objectFiles.isEmpty() || !picObjectFiles.isEmpty()) {
    ccOutputs=new CcCompilationOutputs.Builder().merge(ccOutputs).addLTOBitcodeFile(ccOutputs.getLtoBitcodeFiles()).addObjectFiles(objectFiles).addPicObjectFiles(picObjectFiles).build();
  }
  CcLinkingOutputs ccLinkingOutputs=CcLinkingOutputs.EMPTY;
  if (emitLinkActionsIfEmpty || !ccOutputs.isEmpty()) {
    if (linkType.isStaticLibraryLink()) {
      ccLinkingOutputs=model.createCcLinkActions(ccOutputs);
    }
  }
  CcLinkingOutputs originalLinkingOutputs=ccLinkingOutputs;
  if (!(staticLibraries.isEmpty() && picStaticLibraries.isEmpty() && dynamicLibraries.isEmpty())) {
    ccLinkingOutputs=new CcLinkingOutputs.Builder().merge(ccLinkingOutputs).addStaticLibraries(staticLibraries).addPicStaticLibraries(picStaticLibraries).addDynamicLibraries(dynamicLibraries).addExecutionDynamicLibraries(dynamicLibraries).build();
  }
  DwoArtifactsCollector dwoArtifacts=DwoArtifactsCollector.transitiveCollector(ccOutputs,deps);
  Runfiles cppStaticRunfiles=collectCppRunfiles(ccLinkingOutputs,true);
  Runfiles cppSharedRunfiles=collectCppRunfiles(ccLinkingOutputs,false);
  Map<Class<? extends TransitiveInfoProvider>,TransitiveInfoProvider> providers=new LinkedHashMap<>();
  providers.put(CppRunfilesProvider.class,new CppRunfilesProvider(cppStaticRunfiles,cppSharedRunfiles));
  providers.put(CppCompilationContext.class,cppCompilationContext);
  providers.put(CppDebugFileProvider.class,new CppDebugFileProvider(dwoArtifacts.getDwoArtifacts(),dwoArtifacts.getPicDwoArtifacts()));
  providers.put(TransitiveLipoInfoProvider.class,collectTransitiveLipoInfo(ccOutputs));
  Map<String,NestedSet<Artifact>> outputGroups=new TreeMap<>();
  outputGroups.put(OutputGroupProvider.TEMP_FILES,getTemps(ccOutputs));
  if (emitCompileProviders) {
    boolean isLipoCollector=ruleContext.getFragment(CppConfiguration.class).isLipoContextCollector();
    boolean usePic=CppHelper.usePic(ruleContext,false);
    outputGroups.put(OutputGroupProvider.FILES_TO_COMPILE,ccOutputs.getFilesToCompile(isLipoCollector,usePic));
    outputGroups.put(OutputGroupProvider.COMPILATION_PREREQUISITES,CcCommon.collectCompilationPrerequisites(ruleContext,cppCompilationContext));
  }
  if (emitCcNativeLibrariesProvider) {
    providers.put(CcNativeLibraryProvider.class,new CcNativeLibraryProvider(collectNativeCcLibraries(ccLinkingOutputs)));
  }
  providers.put(CcExecutionDynamicLibrariesProvider.class,collectExecutionDynamicLibraryArtifacts(ccLinkingOutputs.getExecutionDynamicLibraries()));
  boolean forcePic=ruleContext.getFragment(CppConfiguration.class).forcePic();
  if (emitCcSpecificLinkParamsProvider) {
    providers.put(CcSpecificLinkParamsProvider.class,new CcSpecificLinkParamsProvider(createCcLinkParamsStore(ccLinkingOutputs,cppCompilationContext,forcePic)));
  }
 else {
    providers.put(CcLinkParamsProvider.class,new CcLinkParamsProvider(createCcLinkParamsStore(ccLinkingOutputs,cppCompilationContext,forcePic)));
  }
  return new Info(providers,outputGroups,ccOutputs,ccLinkingOutputs,originalLinkingOutputs,cppCompilationContext);
}
