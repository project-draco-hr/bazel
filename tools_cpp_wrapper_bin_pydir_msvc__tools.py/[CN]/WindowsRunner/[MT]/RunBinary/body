def RunBinary(self, binary, args, build_arch, parser):
    "Runs binary on Windows with the passed args.\n\n    Args:\n      binary: The binary to run.\n      args: The arguments to pass to binary.\n      build_arch: Either 'x64' or 'x86', which binary architecture to build for.\n      parser: An ArgParser that contains parsed arguments.\n\n    Returns:\n      The return code from executing binary.\n    "
    filters = ['.*warning LNK4006: __NULL_IMPORT_DESCRIPTOR already defined.*\n', ".*warning LNK4044: unrecognized option '/MT'; ignored.*\n", ".*warning LNK4044: unrecognized option '/link'; ignored.*\n", '.*warning LNK4221: This object file does not define any previously.*\n', '\r\n', '\n\r']
    for arg in args:
        if (len(arg) > MAX_PATH):
            print (((('Warning: arg "' + arg) + '" is > than 260 characters (') + str(len(arg))) + '); programs may crash with long arguments')
        if (os.path.splitext(arg)[1].lower() in ['.c', '.cc', '.cpp', '.s']):
            name = arg.rpartition(ntpath.sep)[2]
            filters.append(name)
    if ('/w' in args):
        args = [arg for arg in args if (arg not in ['/W2', '/W3', '/W4'])]
    build_env = self.SetupEnvironment(build_arch)
    output_filter = re.compile((('(' + ')|('.join(filters)) + ')'))
    includes_filter = re.compile('Note: including file:\\s+(.*)')
    cmd = ([binary] + args)
    proc = subprocess.Popen(cmd, env=build_env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)
    deps = []
    for line in proc.stdout:
        if (not output_filter.match(line)):
            includes = includes_filter.match(line)
            if includes:
                filename = includes.group(1).rstrip()
                deps += [filename]
            else:
                print line.rstrip()
    proc.wait()
    if parser.deps_file:
        with open(parser.deps_file, 'w') as deps_file:
            deps_file.write((parser.output_file + ': \\\n'))
            for (i, dep) in enumerate(deps):
                dep = dep.replace('\\', '/').replace(' ', '\\ ')
                deps_file.write(('  ' + dep))
                if (i < (len(deps) - 1)):
                    deps_file.write(' \\')
                deps_file.write('\n')
    return proc.returncode
