def RunBinary(self, binary, args, build_arch, parser):
    "Runs binary on Windows with the passed args.\n\n    Args:\n      binary: The binary to run.\n      args: The arguments to pass to binary.\n      build_arch: Either 'x64' or 'x86', which binary architecture to build for.\n      parser: An ArgParser that contains parsed arguments.\n\n    Returns:\n      The return code from executing binary.\n    "
    filters = ['.*warning LNK4006: __NULL_IMPORT_DESCRIPTOR already defined.*\n', ".*warning LNK4044: unrecognized option '/MT'; ignored.*\n", ".*warning LNK4044: unrecognized option '/link'; ignored.*\n", '.*warning LNK4221: This object file does not define any previously.*\n', '.*warning C.*\n', '\r\n', '\n\r']
    for arg in args:
        if (len(arg) > MAX_PATH):
            print (((('Warning: arg "' + arg) + '" is > than 260 characters (') + str(len(arg))) + '); programs may crash with long arguments')
        if (os.path.splitext(arg)[1].lower() in ['.c', '.cc', '.cpp', '.s']):
            name = arg.rpartition(ntpath.sep)[2]
            filters.append(name)
    if ('/w' in args):
        args = [arg for arg in args if (arg not in ['/W2', '/W3', '/W4'])]
    build_env = self.SetupEnvironment(build_arch)
    output_filter = re.compile((('(' + ')|('.join(filters)) + ')'))
    includes_filter = re.compile('Note: including file:\\s+(.*)')
    if parser.params_file:
        try:
            params_file = open(parser.params_file, 'w')
            for arg in args:
                params_file.write((arg + '\n'))
            params_file.close()
        except IOError as e:
            print 'Could not open', parser.params_file, 'for writing:', str(e)
            exit((-1))
        cmd = ([binary] + [('@' + os.path.normpath(parser.params_file))])
    else:
        cmd = ([binary] + args)
    proc = subprocess.Popen(cmd, env=build_env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)
    deps = []
    for line in proc.stdout:
        if (not output_filter.match(line)):
            includes = includes_filter.match(line)
            if includes:
                filename = includes.group(1).rstrip()
                deps += [filename]
            else:
                print line.rstrip()
    proc.wait()
    if parser.deps_file:
        with open(parser.deps_file, 'w') as deps_file:
            deps_file.write((parser.output_file + ': \\\n'))
            for (i, dep) in enumerate(deps):
                dep = dep.replace('\\', '/').replace(' ', '\\ ')
                deps_file.write(('  ' + dep))
                if (i < (len(deps) - 1)):
                    deps_file.write(' \\')
                deps_file.write('\n')
    return proc.returncode
