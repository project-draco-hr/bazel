def _ParseArgs(self, argv):
    "Parses argv and replaces its elements using special tokens.\n\n    The following is a list of supported tokens. The format is $TOKEN%d, where\n    %d is the 0-based group number from regex matches of the pattern.\n      $CREATE_PATH%d: Touches a file at the path in the matching token.\n      $LOAD_PARAMS%d: Loads an ld-style params file and appends all arguments to\n                      the current argument list by recursively calling\n                      _ParseArgs.\n      $%d           : Numeric token that just replaces the match group with\n                      the value specified in the match list.\n      $PATH%d       : Replaces the match with a Windows-normalized version of\n                      the match; assumes that the match is a path.\n      $PATH%d_NO_EXT: Same as $PATH but strips out any file extension.\n      $TARGET_ARCH  : Set self.target_arch to 'x86' or 'x64' for '-m32' and\n                      '-m64', respectively.\n      $COMPILE_OUTPUT%d: Sets the output name of a compilation step.\n      $COMPILATION_MODE: Sets self.compilation_mode from the value of a\n                      '-Xcompilation-mode=' flag.\n      $CREATE_PRECOMPILED_HEADER: Informs the system that we are generating a\n                      precompiled header rather than an object file.\n      $GENERATE_DEPS%d: Generates a gcc-style .d file containing dependencies.\n\n    Args:\n      argv: A list of arguments to replace.\n\n    Returns:\n      A list of replaced arguments to pass to the target command.\n\n    Raises:\n      Error: if wrong arguments found\n    "
    i = 0
    matched = []
    unmatched = []
    files = []
    while (i < len(argv)):
        (num_matched, action, groups) = self._MatchOneArg(argv[i:])
        arg = argv[i]
        if (arg.startswith('/Fo') or arg.startswith('/Fa') or arg.startswith('/Fi')):
            self.output_file = arg[3:]
            self.options.append(('/Fd%s.pdb' % self.NormPath(os.path.splitext(self.output_file)[0])))
        if (num_matched == 0):
            if (os.path.isfile(arg) and (os.path.splitext(arg)[1] == '.a') and (os.path.getsize(arg) == 0)):
                i += 1
                continue
            if (arg[0] == '/'):
                self.AddOpt(arg)
            elif os.path.isfile(arg):
                path = self.NormPath(arg)
                ext = os.path.splitext(arg)[1].lower()
                if (ext in ['.s']):
                    path = (ASSEMBLY_AS_C_SOURCE + path)
                files.append(path)
            elif (not arg.endswith(LIB_SUFFIX)):
                unmatched.append(arg)
            i += 1
            continue
        matched += argv[i:(i + num_matched)]
        for entry in action:
            if (entry == '$TARGET_ARCH'):
                if (arg == '-m32'):
                    self.target_arch = 'x86'
                elif (arg == '-m64'):
                    self.target_arch = 'x64'
                else:
                    raise Error(('Unknown target arch flag: %r' % arg))
                continue
            if (entry == '$COMPILATION_MODE'):
                (empty, prefix, mode) = arg.partition('-Xcompilation-mode=')
                if (empty or (not prefix) or (mode not in ['dbg', 'fastbuild', 'opt'])):
                    raise Error(('Invalid compilation mode flag: %r' % arg))
                self.compilation_mode = mode
                continue
            if (not groups):
                self.options.append(entry)
            else:
                for g in xrange(0, len(groups)):
                    value = groups[g]
                    if (entry == ('$CREATE_PATH%d' % g)):
                        with open(value, 'a'):
                            os.utime(value, None)
                        continue
                    if (entry == ('$LOAD_PARAMS%d' % g)):
                        try:
                            params = [line.rstrip() for line in open(value, 'r')]
                            self._ParseArgs(params)
                            self.params_file = (value + '.msvc')
                        except IOError as e:
                            print 'Could not open', value, 'for reading:', str(e)
                            exit((-1))
                        continue
                    if (entry == ('$GENERATE_DEPS%d' % g)):
                        self.options.append('/showIncludes')
                        self.deps_file = value
                        continue
                    patterns = {('$%d' % g): value, ('$PATH%d_NO_EXT' % g): self.NormPath(os.path.splitext(value)[0]), ('$PATH%d' % g): self.NormPath(value), }
                    pattern = re.compile(('(%s)' % '|'.join(map(re.escape, patterns.keys()))))
                    result = pattern.sub((lambda x: patterns[x.group(0)]), entry)
                    self.options.append(result)
        i += num_matched
    if unmatched:
        print ('Warning: Unmatched arguments: ' + ' '.join(unmatched))
    if (('/MT' not in self.options) and ('/MTd' not in self.options)):
        self.AddOpt('/MT')
    self.options += files
