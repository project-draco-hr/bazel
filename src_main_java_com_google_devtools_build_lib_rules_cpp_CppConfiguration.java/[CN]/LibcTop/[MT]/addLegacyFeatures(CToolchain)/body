{
  CToolchain.Builder toolchainBuilder=CToolchain.newBuilder();
  ImmutableSet.Builder<String> featuresBuilder=ImmutableSet.builder();
  for (  CToolchain.Feature feature : toolchain.getFeatureList()) {
    featuresBuilder.add(feature.getName());
  }
  Set<String> features=featuresBuilder.build();
  if (features.contains(CppRuleClasses.NO_LEGACY_FEATURES)) {
    return toolchain;
  }
  try {
    if (!features.contains("use_header_modules")) {
      TextFormat.merge("" + "feature {" + "  name: 'use_header_modules'"+ "  implies: 'use_module_maps'"+ "  requires { feature: 'layering_check' }"+ "  requires { feature: 'header_modules' }"+ "  flag_set {"+ "    action: 'c-compile'"+ "    action: 'c++-compile'"+ "    action: 'c++-header-parsing'"+ "    action: 'c++-header-preprocessing'"+ "    action: 'c++-module-compile'"+ "    flag_group {"+ "      flag: '-Xclang-only=-fmodules'"+ "      flag: '-Xclang-only=-fmodules-decluse'"+ "    }"+ "    flag_group {"+ "      flag: '-Xclang=-fmodule-file=%{module_files}'"+ "    }"+ "  }"+ "}",toolchainBuilder);
    }
    if (!features.contains("module_maps")) {
      TextFormat.merge("" + "feature { name: 'module_maps' }",toolchainBuilder);
    }
    if (!features.contains("use_module_maps")) {
      TextFormat.merge("" + "feature {" + "  name: 'use_module_maps'"+ "  requires: { feature: 'module_maps' }"+ "  flag_set {"+ "    action: 'c-compile'"+ "    action: 'c++-compile'"+ "    action: 'c++-header-parsing'"+ "    action: 'c++-header-preprocessing'"+ "    action: 'c++-module-compile'"+ "    flag_group {"+ "      flag: '-Xclang-only=-fmodule-maps'"+ "      flag: '-Xclang-only=-fmodule-name=%{module_name}'"+ "      flag: '-Xclang-only=-fmodule-map-file=%{module_map_file}'"+ "      flag: '-Xclang=-fno-modules-implicit-maps'"+ "    }"+ "  }"+ "}",toolchainBuilder);
    }
    if (!features.contains("header_modules")) {
      TextFormat.merge("" + "feature {" + "  name: 'header_modules'"+ "  implies: 'use_header_modules'"+ "  flag_set {"+ "    action: 'c++-module-compile'"+ "    flag_group {"+ "      flag: '-x'"+ "      flag: 'c++'"+ "      flag: '-Xclang=-emit-module'"+ "      flag: '-Xcrosstool-module-compilation'"+ "    }"+ "  }"+ "}",toolchainBuilder);
    }
    if (!features.contains("layering_check")) {
      TextFormat.merge("" + "feature {" + "  name: 'layering_check'"+ "  implies: 'use_module_maps'"+ "  flag_set {"+ "    action: 'c-compile'"+ "    action: 'c++-compile'"+ "    action: 'c++-header-parsing'"+ "    action: 'c++-header-preprocessing'"+ "    action: 'c++-module-compile'"+ "    flag_group {"+ "      flag: '-Xclang-only=-fmodules-strict-decluse'"+ "    }"+ "  }"+ "}",toolchainBuilder);
    }
    if (!features.contains("parse_headers")) {
      TextFormat.merge("" + "feature {" + "  name: 'parse_headers'"+ "  flag_set {"+ "    action: 'c++-header-parsing'"+ "    flag_group {"+ "      flag: '-x'"+ "      flag: 'c++-header'"+ "      flag: '-fsyntax-only'"+ "    }"+ "  }"+ "}",toolchainBuilder);
    }
    if (!features.contains("preprocess_headers")) {
      TextFormat.merge("" + "feature {" + "  name: 'preprocess_headers'"+ "  flag_set {"+ "    action: 'c++-header-preprocessing'"+ "    flag_group {"+ "      flag: '-x'"+ "      flag: 'c++'"+ "      flag: '-E'"+ "    }"+ "  }"+ "}",toolchainBuilder);
    }
    if (!features.contains("include_paths")) {
      TextFormat.merge("" + "feature {" + "  name: 'include_paths'"+ "  flag_set {"+ "    action: 'preprocess-assemble'"+ "    action: 'c-compile'"+ "    action: 'c++-compile'"+ "    action: 'c++-header-parsing'"+ "    action: 'c++-header-preprocessing'"+ "    action: 'c++-module-compile'"+ "    flag_group {"+ "      flag: '-iquote'"+ "      flag: '%{quote_include_paths}'"+ "    }"+ "    flag_group {"+ "      flag: '-I%{include_paths}'"+ "    }"+ "    flag_group {"+ "      flag: '-isystem'"+ "      flag: '%{system_include_paths}'"+ "    }"+ "  }"+ "}",toolchainBuilder);
    }
    if (!features.contains("fdo_instrument")) {
      TextFormat.merge("" + "feature {" + "  name: 'fdo_instrument'"+ "  flag_set {"+ "    action: 'c-compile'"+ "    action: 'c++-compile'"+ "    action: 'c++-link'"+ "    flag_group {"+ "      flag: '-fprofile-generate=%{fdo_instrument_path}'"+ "    }"+ "    flag_group {"+ "      flag: '-fno-data-sections'"+ "    }"+ "  }"+ "}",toolchainBuilder);
    }
    if (!features.contains("fdo_optimize")) {
      TextFormat.merge("" + "feature {" + "  name: 'fdo_optimize'"+ "  flag_set {"+ "    action: 'c-compile'"+ "    action: 'c++-compile'"+ "    flag_group {"+ "      flag: '-fprofile-use=%{fdo_profile_path}'"+ "      flag: '-fprofile-correction'"+ "    }"+ "  }"+ "}",toolchainBuilder);
    }
    if (!features.contains("autofdo")) {
      TextFormat.merge("" + "feature {" + "  name: 'autofdo'"+ "  flag_set {"+ "    action: 'c-compile'"+ "    action: 'c++-compile'"+ "    flag_group {"+ "      flag: '-fauto-profile=%{fdo_profile_path}'"+ "      flag: '-fprofile-correction'"+ "    }"+ "  }"+ "}",toolchainBuilder);
    }
    if (!features.contains("lipo")) {
      TextFormat.merge("" + "feature {" + "  name: 'lipo'"+ "  flag_set {"+ "    action: 'c-compile'"+ "    action: 'c++-compile'"+ "    flag_group {"+ "      flag: '-fripa'"+ "    }"+ "  }"+ "}",toolchainBuilder);
    }
  }
 catch (  ParseException e) {
    throw new RuntimeException(e);
  }
  toolchainBuilder.mergeFrom(toolchain);
  return toolchainBuilder.build();
}
