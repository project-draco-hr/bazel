def patch(target, new=DEFAULT, spec=None, create=False, spec_set=None, autospec=None, new_callable=None, **kwargs):
    '\n    `patch` acts as a function decorator, class decorator or a context\n    manager. Inside the body of the function or with statement, the `target`\n    is patched with a `new` object. When the function/with statement exits\n    the patch is undone.\n\n    If `new` is omitted, then the target is replaced with a\n    `MagicMock`. If `patch` is used as a decorator and `new` is\n    omitted, the created mock is passed in as an extra argument to the\n    decorated function. If `patch` is used as a context manager the created\n    mock is returned by the context manager.\n\n    `target` should be a string in the form `\'package.module.ClassName\'`. The\n    `target` is imported and the specified object replaced with the `new`\n    object, so the `target` must be importable from the environment you are\n    calling `patch` from. The target is imported when the decorated function\n    is executed, not at decoration time.\n\n    The `spec` and `spec_set` keyword arguments are passed to the `MagicMock`\n    if patch is creating one for you.\n\n    In addition you can pass `spec=True` or `spec_set=True`, which causes\n    patch to pass in the object being mocked as the spec/spec_set object.\n\n    `new_callable` allows you to specify a different class, or callable object,\n    that will be called to create the `new` object. By default `MagicMock` is\n    used.\n\n    A more powerful form of `spec` is `autospec`. If you set `autospec=True`\n    then the mock with be created with a spec from the object being replaced.\n    All attributes of the mock will also have the spec of the corresponding\n    attribute of the object being replaced. Methods and functions being\n    mocked will have their arguments checked and will raise a `TypeError` if\n    they are called with the wrong signature. For mocks replacing a class,\n    their return value (the \'instance\') will have the same spec as the class.\n\n    Instead of `autospec=True` you can pass `autospec=some_object` to use an\n    arbitrary object as the spec instead of the one being replaced.\n\n    By default `patch` will fail to replace attributes that don\'t exist. If\n    you pass in `create=True`, and the attribute doesn\'t exist, patch will\n    create the attribute for you when the patched function is called, and\n    delete it again afterwards. This is useful for writing tests against\n    attributes that your production code creates at runtime. It is off by by\n    default because it can be dangerous. With it switched on you can write\n    passing tests against APIs that don\'t actually exist!\n\n    Patch can be used as a `TestCase` class decorator. It works by\n    decorating each test method in the class. This reduces the boilerplate\n    code when your test methods share a common patchings set. `patch` finds\n    tests by looking for method names that start with `patch.TEST_PREFIX`.\n    By default this is `test`, which matches the way `unittest` finds tests.\n    You can specify an alternative prefix by setting `patch.TEST_PREFIX`.\n\n    Patch can be used as a context manager, with the with statement. Here the\n    patching applies to the indented block after the with statement. If you\n    use "as" then the patched object will be bound to the name after the\n    "as"; very useful if `patch` is creating a mock object for you.\n\n    `patch` takes arbitrary keyword arguments. These will be passed to\n    the `Mock` (or `new_callable`) on construction.\n\n    `patch.dict(...)`, `patch.multiple(...)` and `patch.object(...)` are\n    available for alternate use-cases.\n    '
    (getter, attribute) = _get_target(target)
    return _patch(getter, attribute, new, spec, create, spec_set, autospec, new_callable, kwargs)
