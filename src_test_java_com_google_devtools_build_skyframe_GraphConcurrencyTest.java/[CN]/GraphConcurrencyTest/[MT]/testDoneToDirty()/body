{
  final int numKeys=1000;
  int numThreads=50;
  final int numBatchRequests=100;
  for (int i=0; i < numKeys; i++) {
    NodeEntry entry=graph.createIfAbsent(key("foo" + i));
    startEvaluation(entry);
    entry.setValue(new StringValue("bar"),new IntVersion(0));
  }
  ExecutorService pool1=Executors.newFixedThreadPool(numThreads);
  ExecutorService pool2=Executors.newFixedThreadPool(numThreads);
  ExecutorService pool3=Executors.newFixedThreadPool(numThreads);
  final CountDownLatch makeBatchCountDownLatch=new CountDownLatch(numBatchRequests);
  final CountDownLatch getBatchCountDownLatch=new CountDownLatch(5);
  final CountDownLatch getCountDownLatch=new CountDownLatch(5);
  for (int i=0; i < numKeys; i++) {
    final int keyNum=i;
    Runnable r1=new Runnable(){
      @Override public void run(){
        try {
          makeBatchCountDownLatch.await();
          getBatchCountDownLatch.await();
          getCountDownLatch.await();
        }
 catch (        InterruptedException e) {
          fail("Test failed: " + e.toString());
        }
        NodeEntry entry=graph.get(key("foo" + keyNum));
        entry.markDirty(true);
        entry.addReverseDepAndCheckIfDone(key("rdep"));
        addTemporaryDirectDep(entry,key("dep"));
        entry.signalDep();
        entry.setValue(new StringValue("bar" + keyNum),new IntVersion(1));
      }
    }
;
    Runnable r2=new Runnable(){
      @Override public void run(){
        try {
          makeBatchCountDownLatch.await();
        }
 catch (        InterruptedException e) {
          fail("Test failed: " + e.toString());
        }
        NodeEntry entry=graph.get(key("foo" + keyNum));
        assertNotEquals(null,entry);
        assertThat(entry.getVersion()).isAnyOf(new IntVersion(0),new IntVersion(1));
        getCountDownLatch.countDown();
      }
    }
;
    pool1.execute(wrapper.wrap(r1));
    pool2.execute(wrapper.wrap(r2));
  }
  Random r=new Random(TestUtils.getRandomSeed());
  for (int i=0; i < numBatchRequests; i++) {
    final List<SkyKey> batch=new ArrayList<>(numKeys);
    for (int j=0; j < numKeys; j++) {
      if (r.nextBoolean()) {
        batch.add(key("foo" + j));
      }
    }
    makeBatchCountDownLatch.countDown();
    Runnable r3=new Runnable(){
      @Override public void run(){
        try {
          makeBatchCountDownLatch.await();
        }
 catch (        InterruptedException e) {
          fail("Test failed: " + e.toString());
        }
        Map<SkyKey,NodeEntry> batchMap=graph.getBatch(batch);
        getBatchCountDownLatch.countDown();
        assertEquals(batch.size(),batchMap.size());
        for (        NodeEntry entry : batchMap.values()) {
          assertThat(entry.getVersion()).isAnyOf(new IntVersion(0),new IntVersion(1));
        }
      }
    }
;
    pool3.execute(wrapper.wrap(r3));
  }
  boolean interrupted=ExecutorUtil.interruptibleShutdown(pool1);
  interrupted|=ExecutorUtil.interruptibleShutdown(pool2);
  interrupted|=ExecutorUtil.interruptibleShutdown(pool3);
  Throwables.propagateIfPossible(wrapper.getFirstThrownError());
  if (interrupted) {
    Thread.currentThread().interrupt();
    throw new InterruptedException();
  }
  for (int i=0; i < numKeys; i++) {
    NodeEntry entry=graph.get(key("foo" + i));
    assertThat(entry.getValue()).isEqualTo(new StringValue("bar" + i));
    assertThat(entry.getVersion()).isEqualTo(new IntVersion(1));
    for (    SkyKey key : entry.getReverseDeps()) {
      assertEquals(key("rdep"),key);
    }
    for (    SkyKey key : entry.getDirectDeps()) {
      assertEquals(key("dep"),key);
    }
  }
}
