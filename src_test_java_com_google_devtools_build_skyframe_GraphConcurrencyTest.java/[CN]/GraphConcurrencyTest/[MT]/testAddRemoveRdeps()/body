{
  SkyKey key=key("foo");
  final NodeEntry entry=Iterables.getOnlyElement(graph.createIfAbsentBatch(ImmutableList.of(key)).values());
  int numThreads=50;
  int numKeys=numThreads;
  final int chunkSize=40;
  final int numIterations=chunkSize * 2;
  final CountDownLatch waitForStart=new CountDownLatch(1);
  final CountDownLatch waitForAddedRdep=new CountDownLatch(numThreads);
  final CountDownLatch waitForSetValue=new CountDownLatch(1);
  ExecutorService pool=Executors.newFixedThreadPool(numThreads);
  assertEquals(DependencyState.NEEDS_SCHEDULING,entry.addReverseDepAndCheckIfDone(key("rdep")));
  for (int i=0; i < numKeys; i++) {
    final int j=i;
    Runnable r=new Runnable(){
      @Override public void run(){
        try {
          waitForStart.await(TestUtils.WAIT_TIMEOUT_SECONDS,TimeUnit.SECONDS);
          for (int k=1; k < chunkSize; k++) {
            assertThat(entry.addReverseDepAndCheckIfDone(key("rdep" + j))).isNotEqualTo(DependencyState.DONE);
            entry.removeInProgressReverseDep(key("rdep" + j));
            assertThat(entry.getInProgressReverseDeps()).doesNotContain(key("rdep" + j));
          }
          assertThat(entry.addReverseDepAndCheckIfDone(key("rdep" + j))).isNotEqualTo(DependencyState.DONE);
          waitForAddedRdep.countDown();
          waitForSetValue.await(TestUtils.WAIT_TIMEOUT_SECONDS,TimeUnit.SECONDS);
        }
 catch (        InterruptedException e) {
          fail("Test failed: " + e.toString());
        }
        for (int k=chunkSize; k <= numIterations; k++) {
          entry.removeReverseDep(key("rdep" + j));
          entry.addReverseDepAndCheckIfDone(key("rdep" + j));
          entry.getReverseDeps();
        }
      }
    }
;
    pool.execute(wrapper.wrap(r));
  }
  waitForStart.countDown();
  waitForAddedRdep.await(TestUtils.WAIT_TIMEOUT_SECONDS,TimeUnit.SECONDS);
  entry.setValue(new StringValue("foo1"),startingVersion);
  waitForSetValue.countDown();
  entry.removeReverseDep(key("rdep"));
  wrapper.waitForTasksAndMaybeThrow();
  assertFalse(ExecutorUtil.interruptibleShutdown(pool));
  assertEquals(new StringValue("foo1"),graph.get(key).getValue());
  assertEquals(numKeys,Iterables.size(graph.get(key).getReverseDeps()));
  graph=getGraph(startingVersion.next());
  NodeEntry sameEntry=Preconditions.checkNotNull(graph.get(key));
  sameEntry.markDirty(true);
  startEvaluation(sameEntry);
  sameEntry.markRebuildingAndGetAllRemainingDirtyDirectDeps();
  sameEntry.setValue(new StringValue("foo2"),startingVersion.next());
  assertEquals(new StringValue("foo2"),graph.get(key).getValue());
  assertEquals(numKeys,Iterables.size(graph.get(key).getReverseDeps()));
}
