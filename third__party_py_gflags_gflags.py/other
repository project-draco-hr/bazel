'This module is used to define and parse command line flags.\n\nThis module defines a *distributed* flag-definition policy: rather than\nan application having to define all flags in or near main(), each python\nmodule defines flags that are useful to it.  When one python module\nimports another, it gains access to the other\'s flags.  (This is\nimplemented by having all modules share a common, global registry object\ncontaining all the flag information.)\n\nFlags are defined through the use of one of the DEFINE_xxx functions.\nThe specific function used determines how the flag is parsed, checked,\nand optionally type-converted, when it\'s seen on the command line.\n\n\nIMPLEMENTATION: DEFINE_* creates a \'Flag\' object and registers it with a\n\'FlagValues\' object (typically the global FlagValues FLAGS, defined\nhere).  The \'FlagValues\' object can scan the command line arguments and\npass flag arguments to the corresponding \'Flag\' objects for\nvalue-checking and type conversion.  The converted flag values are\navailable as attributes of the \'FlagValues\' object.\n\nCode can access the flag through a FlagValues object, for instance\ngflags.FLAGS.myflag.  Typically, the __main__ module passes the command\nline arguments to gflags.FLAGS for parsing.\n\nAt bottom, this module calls getopt(), so getopt functionality is\nsupported, including short- and long-style flags, and the use of -- to\nterminate flags.\n\nMethods defined by the flag module will throw \'FlagsError\' exceptions.\nThe exception argument will be a human-readable string.\n\n\nFLAG TYPES: This is a list of the DEFINE_*\'s that you can do.  All flags\ntake a name, default value, help-string, and optional \'short\' name\n(one-letter name).  Some flags have other arguments, which are described\nwith the flag.\n\nDEFINE_string: takes any input, and interprets it as a string.\n\nDEFINE_bool or\nDEFINE_boolean: typically does not take an argument: say --myflag to\n                set FLAGS.myflag to true, or --nomyflag to set\n                FLAGS.myflag to false.  Alternately, you can say\n                   --myflag=true  or --myflag=t or --myflag=1  or\n                   --myflag=false or --myflag=f or --myflag=0\n\nDEFINE_float: takes an input and interprets it as a floating point\n              number.  Takes optional args lower_bound and upper_bound;\n              if the number specified on the command line is out of\n              range, it will raise a FlagError.\n\nDEFINE_integer: takes an input and interprets it as an integer.  Takes\n                optional args lower_bound and upper_bound as for floats.\n\nDEFINE_enum: takes a list of strings which represents legal values.  If\n             the command-line value is not in this list, raise a flag\n             error.  Otherwise, assign to FLAGS.flag as a string.\n\nDEFINE_list: Takes a comma-separated list of strings on the commandline.\n             Stores them in a python list object.\n\nDEFINE_spaceseplist: Takes a space-separated list of strings on the\n                     commandline.  Stores them in a python list object.\n                     Example: --myspacesepflag "foo bar baz"\n\nDEFINE_multistring: The same as DEFINE_string, except the flag can be\n                    specified more than once on the commandline.  The\n                    result is a python list object (list of strings),\n                    even if the flag is only on the command line once.\n\nDEFINE_multi_int: The same as DEFINE_integer, except the flag can be\n                  specified more than once on the commandline.  The\n                  result is a python list object (list of ints), even if\n                  the flag is only on the command line once.\n\n\nSPECIAL FLAGS: There are a few flags that have special meaning:\n   --help          prints a list of all the flags in a human-readable fashion\n   --helpshort     prints a list of all key flags (see below).\n   --helpxml       prints a list of all flags, in XML format.  DO NOT parse\n                   the output of --help and --helpshort.  Instead, parse\n                   the output of --helpxml.  For more info, see\n                   "OUTPUT FOR --helpxml" below.\n   --flagfile=foo  read flags from file foo.\n   --undefok=f1,f2 ignore unrecognized option errors for f1,f2.\n                   For boolean flags, you should use --undefok=boolflag, and\n                   --boolflag and --noboolflag will be accepted.  Do not use\n                   --undefok=noboolflag.\n   --              as in getopt(), terminates flag-processing\n\n\nFLAGS VALIDATORS: If your program:\n  - requires flag X to be specified\n  - needs flag Y to match a regular expression\n  - or requires any more general constraint to be satisfied\nthen validators are for you!\n\nEach validator represents a constraint over one flag, which is enforced\nstarting from the initial parsing of the flags and until the program\nterminates.\n\nAlso, lower_bound and upper_bound for numerical flags are enforced using flag\nvalidators.\n\nHowto:\nIf you want to enforce a constraint over one flag, use\n\ngflags.RegisterValidator(flag_name,\n                        checker,\n                        message=\'Flag validation failed\',\n                        flag_values=FLAGS)\n\nAfter flag values are initially parsed, and after any change to the specified\nflag, method checker(flag_value) will be executed. If constraint is not\nsatisfied, an IllegalFlagValue exception will be raised. See\nRegisterValidator\'s docstring for a detailed explanation on how to construct\nyour own checker.\n\n\nEXAMPLE USAGE:\n\nFLAGS = gflags.FLAGS\n\ngflags.DEFINE_integer(\'my_version\', 0, \'Version number.\')\ngflags.DEFINE_string(\'filename\', None, \'Input file name\', short_name=\'f\')\n\ngflags.RegisterValidator(\'my_version\',\n                        lambda value: value % 2 == 0,\n                        message=\'--my_version must be divisible by 2\')\ngflags.MarkFlagAsRequired(\'filename\')\n\n\nNOTE ON --flagfile:\n\nFlags may be loaded from text files in addition to being specified on\nthe commandline.\n\nAny flags you don\'t feel like typing, throw them in a file, one flag per\nline, for instance:\n   --myflag=myvalue\n   --nomyboolean_flag\nYou then specify your file with the special flag \'--flagfile=somefile\'.\nYou CAN recursively nest flagfile= tokens OR use multiple files on the\ncommand line.  Lines beginning with a single hash \'#\' or a double slash\n\'//\' are comments in your flagfile.\n\nAny flagfile=<file> will be interpreted as having a relative path from\nthe current working directory rather than from the place the file was\nincluded from:\n   myPythonScript.py --flagfile=config/somefile.cfg\n\nIf somefile.cfg includes further --flagfile= directives, these will be\nreferenced relative to the original CWD, not from the directory the\nincluding flagfile was found in!\n\nThe caveat applies to people who are including a series of nested files\nin a different dir than they are executing out of.  Relative path names\nare always from CWD, not from the directory of the parent include\nflagfile. We do now support \'~\' expanded directory names.\n\nAbsolute path names ALWAYS work!\n\n\nEXAMPLE USAGE:\n\n\n  FLAGS = gflags.FLAGS\n\n  # Flag names are globally defined!  So in general, we need to be\n  # careful to pick names that are unlikely to be used by other libraries.\n  # If there is a conflict, we\'ll get an error at import time.\n  gflags.DEFINE_string(\'name\', \'Mr. President\', \'your name\')\n  gflags.DEFINE_integer(\'age\', None, \'your age in years\', lower_bound=0)\n  gflags.DEFINE_boolean(\'debug\', False, \'produces debugging output\')\n  gflags.DEFINE_enum(\'gender\', \'male\', [\'male\', \'female\'], \'your gender\')\n\n  def main(argv):\n    try:\n      argv = FLAGS(argv)  # parse flags\n    except gflags.FlagsError, e:\n      print \'%s\\nUsage: %s ARGS\\n%s\' % (e, sys.argv[0], FLAGS)\n      sys.exit(1)\n    if FLAGS.debug: print \'non-flag arguments:\', argv\n    print \'Happy Birthday\', FLAGS.name\n    if FLAGS.age is not None:\n      print \'You are a %d year old %s\' % (FLAGS.age, FLAGS.gender)\n\n  if __name__ == \'__main__\':\n    main(sys.argv)\n\n\nKEY FLAGS:\n\nAs we already explained, each module gains access to all flags defined\nby all the other modules it transitively imports.  In the case of\nnon-trivial scripts, this means a lot of flags ...  For documentation\npurposes, it is good to identify the flags that are key (i.e., really\nimportant) to a module.  Clearly, the concept of "key flag" is a\nsubjective one.  When trying to determine whether a flag is key to a\nmodule or not, assume that you are trying to explain your module to a\npotential user: which flags would you really like to mention first?\n\nWe\'ll describe shortly how to declare which flags are key to a module.\nFor the moment, assume we know the set of key flags for each module.\nThen, if you use the app.py module, you can use the --helpshort flag to\nprint only the help for the flags that are key to the main module, in a\nhuman-readable format.\n\nNOTE: If you need to parse the flag help, do NOT use the output of\n--help / --helpshort.  That output is meant for human consumption, and\nmay be changed in the future.  Instead, use --helpxml; flags that are\nkey for the main module are marked there with a <key>yes</key> element.\n\nThe set of key flags for a module M is composed of:\n\n1. Flags defined by module M by calling a DEFINE_* function.\n\n2. Flags that module M explictly declares as key by using the function\n\n     DECLARE_key_flag(<flag_name>)\n\n3. Key flags of other modules that M specifies by using the function\n\n     ADOPT_module_key_flags(<other_module>)\n\n   This is a "bulk" declaration of key flags: each flag that is key for\n   <other_module> becomes key for the current module too.\n\nNotice that if you do not use the functions described at points 2 and 3\nabove, then --helpshort prints information only about the flags defined\nby the main module of our script.  In many cases, this behavior is good\nenough.  But if you move part of the main module code (together with the\nrelated flags) into a different module, then it is nice to use\nDECLARE_key_flag / ADOPT_module_key_flags and make sure --helpshort\nlists all relevant flags (otherwise, your code refactoring may confuse\nyour users).\n\nNote: each of DECLARE_key_flag / ADOPT_module_key_flags has its own\npluses and minuses: DECLARE_key_flag is more targeted and may lead a\nmore focused --helpshort documentation.  ADOPT_module_key_flags is good\nfor cases when an entire module is considered key to the current script.\nAlso, it does not require updates to client scripts when a new flag is\nadded to the module.\n\n\nEXAMPLE USAGE 2 (WITH KEY FLAGS):\n\nConsider an application that contains the following three files (two\nauxiliary modules and a main module)\n\nFile libfoo.py:\n\n  import gflags\n\n  gflags.DEFINE_integer(\'num_replicas\', 3, \'Number of replicas to start\')\n  gflags.DEFINE_boolean(\'rpc2\', True, \'Turn on the usage of RPC2.\')\n\n  ... some code ...\n\nFile libbar.py:\n\n  import gflags\n\n  gflags.DEFINE_string(\'bar_gfs_path\', \'/gfs/path\',\n                      \'Path to the GFS files for libbar.\')\n  gflags.DEFINE_string(\'email_for_bar_errors\', \'bar-team@google.com\',\n                      \'Email address for bug reports about module libbar.\')\n  gflags.DEFINE_boolean(\'bar_risky_hack\', False,\n                       \'Turn on an experimental and buggy optimization.\')\n\n  ... some code ...\n\nFile myscript.py:\n\n  import gflags\n  import libfoo\n  import libbar\n\n  gflags.DEFINE_integer(\'num_iterations\', 0, \'Number of iterations.\')\n\n  # Declare that all flags that are key for libfoo are\n  # key for this module too.\n  gflags.ADOPT_module_key_flags(libfoo)\n\n  # Declare that the flag --bar_gfs_path (defined in libbar) is key\n  # for this module.\n  gflags.DECLARE_key_flag(\'bar_gfs_path\')\n\n  ... some code ...\n\nWhen myscript is invoked with the flag --helpshort, the resulted help\nmessage lists information about all the key flags for myscript:\n--num_iterations, --num_replicas, --rpc2, and --bar_gfs_path.\n\nOf course, myscript uses all the flags declared by it (in this case,\njust --num_replicas) or by any of the modules it transitively imports\n(e.g., the modules libfoo, libbar).  E.g., it can access the value of\nFLAGS.bar_risky_hack, even if --bar_risky_hack is not declared as a key\nflag for myscript.\n\n\nOUTPUT FOR --helpxml:\n\nThe --helpxml flag generates output with the following structure:\n\n<?xml version="1.0"?>\n<AllFlags>\n  <program>PROGRAM_BASENAME</program>\n  <usage>MAIN_MODULE_DOCSTRING</usage>\n  (<flag>\n    [<key>yes</key>]\n    <file>DECLARING_MODULE</file>\n    <name>FLAG_NAME</name>\n    <meaning>FLAG_HELP_MESSAGE</meaning>\n    <default>DEFAULT_FLAG_VALUE</default>\n    <current>CURRENT_FLAG_VALUE</current>\n    <type>FLAG_TYPE</type>\n    [OPTIONAL_ELEMENTS]\n  </flag>)*\n</AllFlags>\n\nNotes:\n\n1. The output is intentionally similar to the output generated by the\nC++ command-line flag library.  The few differences are due to the\nPython flags that do not have a C++ equivalent (at least not yet),\ne.g., DEFINE_list.\n\n2. New XML elements may be added in the future.\n\n3. DEFAULT_FLAG_VALUE is in serialized form, i.e., the string you can\npass for this flag on the command-line.  E.g., for a flag defined\nusing DEFINE_list, this field may be foo,bar, not [\'foo\', \'bar\'].\n\n4. CURRENT_FLAG_VALUE is produced using str().  This means that the\nstring \'false\' will be represented in the same way as the boolean\nFalse.  Using repr() would have removed this ambiguity and simplified\nparsing, but would have broken the compatibility with the C++\ncommand-line flags.\n\n5. OPTIONAL_ELEMENTS describe elements relevant for certain kinds of\nflags: lower_bound, upper_bound (for flags that specify bounds),\nenum_value (for enum flags), list_separator (for flags that consist of\na list of values, separated by a special token).\n\n6. We do not provide any example here: please use --helpxml instead.\n\nThis module requires at least python 2.2.1 to run.\n'
import cgi
import getopt
import os
import re
import string
import struct
import sys
try:
    import fcntl
except ImportError:
    fcntl = None
try:
    import termios
except ImportError:
    termios = None
import gflags_validators
_RUNNING_PYCHECKER = ('pychecker.python' in sys.modules)
_exported_flags = {}
_help_width = 80
FLAGS = FlagValues()
DEFINE_bool = DEFINE_boolean
DEFINE_flag(HelpFlag())
DEFINE_flag(HelpshortFlag())
DEFINE_flag(HelpXMLFlag())
_SPECIAL_FLAGS = FlagValues()
DEFINE_string('flagfile', '', 'Insert flag definitions from the given file into the command line.', _SPECIAL_FLAGS)
DEFINE_string('undefok', '', 'comma-separated list of flag names that it is okay to specify on the command line even if the program does not define a flag with that name.  IMPORTANT: flags in this list that have arguments MUST use the --flag=value format.', _SPECIAL_FLAGS)
