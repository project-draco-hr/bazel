{
  ImmutableList<Artifact> srcJars=ImmutableList.of();
  ImmutableList<Artifact> jars=collectJars(ruleContext);
  Artifact srcJar=ruleContext.getPrerequisiteArtifact("srcjar",Mode.TARGET);
  if (ruleContext.hasErrors()) {
    return null;
  }
  ImmutableList<TransitiveInfoCollection> targets=ImmutableList.copyOf(ruleContext.getPrerequisites("exports",Mode.TARGET));
  final JavaCommon common=new JavaCommon(ruleContext,semantics,targets,targets,targets);
  semantics.checkRule(ruleContext,common);
  JavaCompilationHelper helper=new JavaCompilationHelper(ruleContext,semantics,ImmutableList.<String>of(),new JavaTargetAttributes.Builder(semantics));
  ImmutableMap.Builder<Artifact,Artifact> compilationToRuntimeJarMap=ImmutableMap.builder();
  ImmutableList<Artifact> interfaceJars=processWithIjar(jars,helper,compilationToRuntimeJarMap);
  common.setJavaCompilationArtifacts(collectJavaArtifacts(jars,interfaceJars));
  CppCompilationContext transitiveCppDeps=common.collectTransitiveCppDeps();
  NestedSet<LinkerInput> transitiveJavaNativeLibraries=common.collectTransitiveJavaNativeLibraries();
  boolean neverLink=JavaCommon.isNeverLink(ruleContext);
  JavaCompilationArgs javaCompilationArgs=common.collectJavaCompilationArgs(false,neverLink,compilationArgsFromSources());
  JavaCompilationArgs recursiveJavaCompilationArgs=common.collectJavaCompilationArgs(true,neverLink,compilationArgsFromSources());
  NestedSet<Artifact> transitiveJavaSourceJars=collectTransitiveJavaSourceJars(ruleContext,srcJar);
  if (srcJar != null) {
    srcJars=ImmutableList.of(srcJar);
  }
  Runfiles runfiles=neverLink ? Runfiles.EMPTY : new Runfiles.Builder().addArtifacts(common.getJavaCompilationArtifacts().getRuntimeJars()).addTargets(targets,RunfilesProvider.DEFAULT_RUNFILES).addRunfiles(ruleContext,RunfilesProvider.DEFAULT_RUNFILES).addTargets(targets,JavaRunfilesProvider.TO_RUNFILES).add(ruleContext,JavaRunfilesProvider.TO_RUNFILES).build();
  CcLinkParamsStore ccLinkParamsStore=new CcLinkParamsStore(){
    @Override protected void collect(    CcLinkParams.Builder builder,    boolean linkingStatically,    boolean linkShared){
      builder.addTransitiveTargets(common.targetsTreatedAsDeps(ClasspathType.BOTH),JavaCcLinkParamsProvider.TO_LINK_PARAMS,CcLinkParamsProvider.TO_LINK_PARAMS);
    }
  }
;
  RuleConfiguredTargetBuilder ruleBuilder=new RuleConfiguredTargetBuilder(ruleContext);
  NestedSetBuilder<Artifact> filesBuilder=NestedSetBuilder.stableOrder();
  filesBuilder.addAll(jars);
  semantics.addProviders(ruleContext,common,ImmutableList.<String>of(),null,srcJar,null,compilationToRuntimeJarMap.build(),helper,filesBuilder,ruleBuilder);
  NestedSet<Artifact> filesToBuild=filesBuilder.build();
  JavaSourceInfoProvider javaSourceInfoProvider=new JavaSourceInfoProvider.Builder().setJarFiles(jars).setSourceJarsForJarFiles(srcJars).build();
  common.addTransitiveInfoProviders(ruleBuilder,filesToBuild,null);
  return ruleBuilder.setFilesToBuild(filesToBuild).add(JavaRuntimeJarProvider.class,new JavaRuntimeJarProvider(common.getJavaCompilationArtifacts().getRuntimeJars())).add(JavaNeverlinkInfoProvider.class,new JavaNeverlinkInfoProvider(neverLink)).add(RunfilesProvider.class,RunfilesProvider.simple(runfiles)).add(CcLinkParamsProvider.class,new CcLinkParamsProvider(ccLinkParamsStore)).add(JavaCompilationArgsProvider.class,new JavaCompilationArgsProvider(javaCompilationArgs,recursiveJavaCompilationArgs)).add(JavaNativeLibraryProvider.class,new JavaNativeLibraryProvider(transitiveJavaNativeLibraries)).add(CppCompilationContext.class,transitiveCppDeps).add(JavaSourceInfoProvider.class,javaSourceInfoProvider).add(JavaSourceJarsProvider.class,new JavaSourceJarsProvider(transitiveJavaSourceJars,srcJars)).addOutputGroup(JavaSemantics.SOURCE_JARS_OUTPUT_GROUP,transitiveJavaSourceJars).build();
}
