{
  FeatureConfiguration featureConfiguration=CcCommon.configureFeatures(ruleContext);
  final CcCommon common=new CcCommon(ruleContext,featureConfiguration);
  CcLibraryHelper helper=new CcLibraryHelper(ruleContext,semantics,featureConfiguration).fromCommon(common).addLinkopts(common.getLinkopts()).addPublicHeaders(CcCommon.getHeaders(ruleContext)).enableCcNativeLibrariesProvider().enableCompileProviders().enableInterfaceSharedObjects().setGenerateLinkActionsIfEmpty(ruleContext.getRule().getRuleClassObject().getImplicitOutputsFunction() != ImplicitOutputsFunction.NONE).setLinkType(linkType).setNeverLink(neverLink);
  if (collectLinkstamp) {
    helper.addLinkstamps(ruleContext.getPrerequisites("linkstamp",Mode.TARGET));
  }
  PathFragment soImplFilename=null;
  if (ruleContext.getRule().isAttrDefined("outs",Type.STRING_LIST)) {
    List<String> outs=ruleContext.attributes().get("outs",Type.STRING_LIST);
    if (outs.size() > 1) {
      ruleContext.attributeError("outs","must be a singleton list");
    }
 else     if (outs.size() == 1) {
      soImplFilename=CppHelper.getLinkedFilename(ruleContext,LinkTargetType.DYNAMIC_LIBRARY);
      soImplFilename=soImplFilename.replaceName(outs.get(0));
      if (!soImplFilename.getPathString().endsWith(".so")) {
        ruleContext.attributeError("outs","file name must end in '.so'");
      }
    }
  }
  if (ruleContext.getRule().isAttrDefined("srcs",Type.LABEL_LIST)) {
    helper.addPrivateHeaders(FileType.filter(ruleContext.getPrerequisiteArtifacts("srcs",Mode.TARGET).list(),CppFileTypes.CPP_HEADER));
    ruleContext.checkSrcsSamePackage(true);
  }
  if (ruleContext.getRule().isAttrDefined("textual_hdrs",Type.LABEL_LIST)) {
    helper.addPublicTextualHeaders(ruleContext.getPrerequisiteArtifacts("textual_hdrs",Mode.TARGET).list());
  }
  if (common.getLinkopts().contains("-static")) {
    ruleContext.attributeWarning("linkopts","Using '-static' here won't work. " + "Did you mean to use 'linkstatic=1' instead?");
  }
  boolean createDynamicLibrary=!linkStatic && appearsToHaveObjectFiles(ruleContext.attributes());
  helper.setCreateDynamicLibrary(createDynamicLibrary);
  helper.setDynamicLibraryPath(soImplFilename);
  if (!createDynamicLibrary && ruleContext.attributes().isConfigurable("srcs",Type.LABEL_LIST)) {
    PathFragment solib=CppHelper.getLinkedFilename(ruleContext,LinkTargetType.DYNAMIC_LIBRARY);
    Artifact solibArtifact=ruleContext.getAnalysisEnvironment().getDerivedArtifact(solib,ruleContext.getBinOrGenfilesDirectory());
    ruleContext.registerAction(new FailAction(ruleContext.getActionOwner(),ImmutableList.of(solibArtifact),"configurable \"srcs\" triggers an implicit .so output " + "even though there are no sources to compile in this configuration"));
  }
  Iterable<LibraryToLink> staticLibrariesFromSrcs=LinkerInputs.opaqueLibrariesToLink(common.getStaticLibrariesFromSrcs());
  helper.addStaticLibraries(staticLibrariesFromSrcs);
  helper.addPicStaticLibraries(Iterables.filter(staticLibrariesFromSrcs,PIC_STATIC_FILTER));
  helper.addPicStaticLibraries(common.getPicStaticLibrariesFromSrcs());
  helper.addDynamicLibraries(Iterables.transform(common.getSharedLibrariesFromSrcs(),new Function<Artifact,LibraryToLink>(){
    @Override public LibraryToLink apply(    Artifact library){
      return common.getDynamicLibrarySymlink(library,true);
    }
  }
));
  CcLibraryHelper.Info info=helper.build();
  CcLinkingOutputs linkedLibraries=info.getCcLinkingOutputsExcludingPrecompiledLibraries();
  NestedSet<Artifact> artifactsToForce=collectHiddenTopLevelArtifacts(ruleContext,common,info.getCcCompilationOutputs());
  NestedSetBuilder<Artifact> filesBuilder=NestedSetBuilder.stableOrder();
  filesBuilder.addAll(LinkerInputs.toLibraryArtifacts(linkedLibraries.getStaticLibraries()));
  filesBuilder.addAll(LinkerInputs.toLibraryArtifacts(linkedLibraries.getPicStaticLibraries()));
  filesBuilder.addAll(LinkerInputs.toNonSolibArtifacts(linkedLibraries.getDynamicLibraries()));
  filesBuilder.addAll(LinkerInputs.toNonSolibArtifacts(linkedLibraries.getExecutionDynamicLibraries()));
  CcLinkingOutputs linkingOutputs=info.getCcLinkingOutputs();
  warnAboutEmptyLibraries(ruleContext,info.getCcCompilationOutputs(),linkStatic);
  NestedSet<Artifact> filesToBuild=filesBuilder.build();
  Runfiles staticRunfiles=collectRunfiles(ruleContext,linkingOutputs,neverLink,addDynamicRuntimeInputArtifactsToRunfiles,true);
  Runfiles sharedRunfiles=collectRunfiles(ruleContext,linkingOutputs,neverLink,addDynamicRuntimeInputArtifactsToRunfiles,false);
  List<Artifact> instrumentedObjectFiles=new ArrayList<>();
  instrumentedObjectFiles.addAll(info.getCcCompilationOutputs().getObjectFiles(false));
  instrumentedObjectFiles.addAll(info.getCcCompilationOutputs().getObjectFiles(true));
  InstrumentedFilesProvider instrumentedFilesProvider=common.getInstrumentedFilesProvider(instrumentedObjectFiles);
  targetBuilder.setFilesToBuild(filesToBuild).addProviders(info.getProviders()).addSkylarkTransitiveInfo(CcSkylarkApiProvider.NAME,new CcSkylarkApiProvider()).addOutputGroups(info.getOutputGroups()).add(InstrumentedFilesProvider.class,instrumentedFilesProvider).add(RunfilesProvider.class,RunfilesProvider.withData(staticRunfiles,sharedRunfiles)).add(CppRunfilesProvider.class,new CppRunfilesProvider(staticRunfiles,sharedRunfiles)).addOutputGroup(OutputGroupProvider.HIDDEN_TOP_LEVEL,artifactsToForce).addOutputGroup(OutputGroupProvider.BASELINE_COVERAGE,BaselineCoverageAction.getBaselineCoverageArtifacts(ruleContext,instrumentedFilesProvider.getInstrumentedFiles()));
}
