{
  deleteTreesBelowNotPrefixed();
  Map<PackageIdentifier,Set<Path>> dirRootsMap=Maps.newTreeMap();
  for (  Map.Entry<PackageIdentifier,Path> entry : packageRoots.entrySet()) {
    PackageIdentifier pkgId=entry.getKey();
    Path pkgRoot=entry.getValue();
    for (int i=1; i <= pkgId.getPackageFragment().segmentCount(); i++) {
      if (pkgId.equals(Label.EXTERNAL_PACKAGE_IDENTIFIER)) {
        continue;
      }
      PackageIdentifier dir=createInRepo(pkgId,pkgId.getPackageFragment().subFragment(0,i));
      Set<Path> roots=dirRootsMap.get(dir);
      if (roots == null) {
        roots=Sets.newHashSet();
        dirRootsMap.put(dir,roots);
      }
      roots.add(pkgRoot);
    }
  }
  for (  Map.Entry<PackageIdentifier,Set<Path>> entry : dirRootsMap.entrySet()) {
    PackageIdentifier dir=entry.getKey();
    if (!isPackage(dir)) {
      PackageIdentifier parentPackage=findParentPackage(dir);
      if (parentPackage != null) {
        entry.getValue().add(packageRoots.get(parentPackage));
      }
    }
  }
  for (  Map.Entry<PackageIdentifier,Set<Path>> entry : dirRootsMap.entrySet()) {
    PackageIdentifier dir=entry.getKey();
    if (!dir.getRepository().isMain()) {
      FileSystemUtils.createDirectoryAndParents(workspace.getRelative(dir.getRepository().getPathUnderExecRoot()));
    }
    if (entry.getValue().size() > 1) {
      if (LOG_FINER) {
        log.finer("mkdir " + workspace.getRelative(dir.getPathUnderExecRoot()));
      }
      FileSystemUtils.createDirectoryAndParents(workspace.getRelative(dir.getPathUnderExecRoot()));
    }
  }
  for (  Map.Entry<PackageIdentifier,Set<Path>> entry : dirRootsMap.entrySet()) {
    PackageIdentifier dir=entry.getKey();
    Set<Path> roots=entry.getValue();
    if (roots.size() == 1) {
      if (dir.getPackageFragment().segmentCount() > 1 && dirRootsMap.get(getParent(dir)).size() == 1) {
        continue;
      }
      Path root=roots.iterator().next();
      if (LOG_FINER) {
        log.finer("ln -s " + root.getRelative(dir.getPackageFragment()) + " "+ workspace.getRelative(dir.getPathUnderExecRoot()));
      }
      workspace.getRelative(dir.getPathUnderExecRoot()).createSymbolicLink(root.getRelative(dir.getPackageFragment()));
    }
  }
  for (  Map.Entry<PackageIdentifier,Set<Path>> entry : dirRootsMap.entrySet()) {
    PackageIdentifier child=entry.getKey();
    if (entry.getValue().size() > 1) {
      PackageIdentifier parent=longestPathPrefix(child,packageRoots.keySet());
      linkDirectoryEntries(parent,child,dirRootsMap);
    }
  }
  for (  Map.Entry<PackageIdentifier,Path> entry : packageRoots.entrySet()) {
    PackageIdentifier pkgId=entry.getKey();
    if (!pkgId.getPackageFragment().equals(PathFragment.EMPTY_FRAGMENT)) {
      continue;
    }
    Path execrootDirectory=workspace.getRelative(pkgId.getPathUnderExecRoot());
    if (!execrootDirectory.exists()) {
      FileSystemUtils.createDirectoryAndParents(execrootDirectory);
    }
    for (    Path target : entry.getValue().getDirectoryEntries()) {
      String baseName=target.getBaseName();
      Path execPath=execrootDirectory.getRelative(baseName);
      if (!baseName.startsWith(productName + "-") && !execPath.exists(Symlinks.NOFOLLOW)) {
        execPath.createSymbolicLink(target);
      }
    }
  }
  if (legacyExternalRunfiles) {
    workspace.getRelative(Label.EXTERNAL_PACKAGE_NAME).createSymbolicLink(workspace.getRelative(Label.EXTERNAL_PATH_PREFIX));
  }
  symlinkCorrectWorkspaceName();
}
