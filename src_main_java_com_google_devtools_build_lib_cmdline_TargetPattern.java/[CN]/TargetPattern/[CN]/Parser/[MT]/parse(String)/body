{
  String originalPattern=pattern;
  final boolean includesRepo=pattern.startsWith("@");
  RepositoryName repository=PackageIdentifier.DEFAULT_REPOSITORY_NAME;
  if (includesRepo) {
    int pkgStart=pattern.indexOf("//");
    if (pkgStart < 0) {
      throw new TargetParsingException("Couldn't find package in target " + pattern);
    }
    try {
      repository=RepositoryName.create(pattern.substring(0,pkgStart));
    }
 catch (    LabelSyntaxException e) {
      throw new TargetParsingException(e.getMessage());
    }
    pattern=pattern.substring(pkgStart);
  }
  final boolean isAbsolute=pattern.startsWith("//");
  pattern=isAbsolute ? pattern.substring(2) : absolutize(pattern);
  if (pattern.startsWith("/")) {
    throw new TargetParsingException("not a relative path or label: '" + pattern + "'");
  }
  if (pattern.isEmpty()) {
    throw new TargetParsingException("the empty string is not a valid target");
  }
  if (pattern.endsWith("/BUILD")) {
    pattern=pattern.substring(0,pattern.length() - 6) + ":BUILD";
  }
  int colonIndex=pattern.lastIndexOf(':');
  String packagePart=colonIndex < 0 ? pattern : pattern.substring(0,colonIndex);
  String targetPart=colonIndex < 0 ? "" : pattern.substring(colonIndex + 1);
  if (packagePart.equals("...")) {
    packagePart="/...";
  }
  if (packagePart.endsWith("/")) {
    throw new TargetParsingException("The package part of '" + originalPattern + "' should not end in a slash");
  }
  if (packagePart.endsWith("/...")) {
    String realPackagePart=removeSuffix(packagePart,"/...");
    if (targetPart.isEmpty() || ALL_RULES_IN_SUFFIXES.contains(targetPart)) {
      return new TargetsBelowDirectory(originalPattern,realPackagePart,true);
    }
 else     if (ALL_TARGETS_IN_SUFFIXES.contains(targetPart)) {
      return new TargetsBelowDirectory(originalPattern,realPackagePart,false);
    }
  }
  if (ALL_RULES_IN_SUFFIXES.contains(targetPart)) {
    PackageIdentifier packageIdentifier;
    try {
      packageIdentifier=PackageIdentifier.parse(repository.getName() + "//" + packagePart);
    }
 catch (    LabelSyntaxException e) {
      throw new TargetParsingException("Invalid package name '" + packagePart + "': "+ e.getMessage());
    }
    return new TargetsInPackage(originalPattern,packageIdentifier,targetPart,isAbsolute,true,true);
  }
  if (ALL_TARGETS_IN_SUFFIXES.contains(targetPart)) {
    PackageIdentifier packageIdentifier;
    try {
      packageIdentifier=PackageIdentifier.parse(repository.getName() + "//" + packagePart);
    }
 catch (    LabelSyntaxException e) {
      throw new TargetParsingException("Invalid package name '" + packagePart + "': "+ e.getMessage());
    }
    return new TargetsInPackage(originalPattern,packageIdentifier,targetPart,isAbsolute,false,true);
  }
  if (includesRepo || isAbsolute || pattern.contains(":")) {
    PackageAndTarget packageAndTarget;
    String fullLabel=repository.getName() + "//" + pattern;
    try {
      packageAndTarget=LabelValidator.validateAbsoluteLabel(fullLabel);
    }
 catch (    BadLabelException e) {
      String error="invalid target format '" + originalPattern + "': "+ e.getMessage();
      throw new TargetParsingException(error);
    }
    return new SingleTarget(fullLabel,packageAndTarget.getPackageName(),originalPattern);
  }
  int slashIndex=pattern.indexOf('/');
  String packageName=pattern;
  if (slashIndex > 0) {
    packageName=pattern.substring(0,slashIndex);
  }
  String errorMessage=LabelValidator.validatePackageName(packageName);
  if (errorMessage != null) {
    throw new TargetParsingException("Bad target pattern '" + originalPattern + "': "+ errorMessage);
  }
  return new InterpretPathAsTarget(pattern,originalPattern);
}
