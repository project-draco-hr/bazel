{
  final FilteringPolicy actualPolicy=rulesOnly ? FilteringPolicies.and(FilteringPolicies.RULES_ONLY,policy) : policy;
  PathFragment pathFragment=TargetPatternResolverUtil.getPathFragment(directory);
  Iterable<PathFragment> packagesUnderDirectory=recursivePackageProvider.getPackagesUnderDirectory(repository,pathFragment,excludedSubdirectories);
  Iterable<PackageIdentifier> pkgIds=Iterables.transform(packagesUnderDirectory,new Function<PathFragment,PackageIdentifier>(){
    @Override public PackageIdentifier apply(    PathFragment path){
      return PackageIdentifier.create(repository,path);
    }
  }
);
  final AtomicBoolean foundTarget=new AtomicBoolean(false);
  final AtomicReference<InterruptedException> interrupt=new AtomicReference<>();
  final AtomicReference<TargetParsingException> parsingException=new AtomicReference<>();
  final AtomicReference<Exception> genericException=new AtomicReference<>();
  final Object callbackLock=new Object();
  List<List<PackageIdentifier>> partitions=ImmutableList.copyOf(Iterables.partition(pkgIds,MAX_PACKAGES_BULK_GET));
  ArrayList<ListenableFuture<?>> futures=new ArrayList<>(partitions.size());
  for (  final Iterable<PackageIdentifier> pkgIdBatch : partitions) {
    futures.add(executor.submit(new Runnable(){
      @Override public void run(){
        Iterable<ResolvedTargets<Target>> resolvedTargets;
        try {
          resolvedTargets=bulkGetTargetsInPackage(originalPattern,pkgIdBatch,NO_FILTER).values();
        }
 catch (        InterruptedException e) {
          interrupt.compareAndSet(null,e);
          return;
        }
catch (        TargetParsingException e) {
          parsingException.compareAndSet(null,e);
          return;
        }
catch (        RuntimeException e) {
          genericException.compareAndSet(null,e);
          return;
        }
        List<Target> filteredTargets=new ArrayList<>(calculateSize(resolvedTargets));
        for (        ResolvedTargets<Target> targets : resolvedTargets) {
          for (          Target target : targets.getTargets()) {
            foundTarget.set(true);
            if (actualPolicy.shouldRetain(target,false)) {
              filteredTargets.add(target);
            }
          }
        }
        try {
synchronized (callbackLock) {
            callback.process(filteredTargets);
          }
        }
 catch (        InterruptedException e) {
          interrupt.compareAndSet(null,e);
        }
catch (        Exception e) {
          genericException.compareAndSet(e,null);
        }
      }
    }
));
  }
  try {
    Futures.allAsList(futures).get();
  }
 catch (  ExecutionException e) {
    throw new IllegalStateException(e);
  }
  Throwables.propagateIfInstanceOf(interrupt.get(),InterruptedException.class);
  Throwables.propagateIfInstanceOf(parsingException.get(),TargetParsingException.class);
  Throwables.propagateIfPossible(genericException.get(),exceptionClass);
  if (!foundTarget.get()) {
    throw new TargetParsingException("no targets found beneath '" + pathFragment + "'");
  }
}
