{
  FilteringPolicy actualPolicy=rulesOnly ? FilteringPolicies.and(FilteringPolicies.RULES_ONLY,policy) : policy;
  ImmutableSet<PathFragment> excludedPathFragments=TargetPatternResolverUtil.getPathFragments(excludedSubdirectories);
  PathFragment pathFragment=TargetPatternResolverUtil.getPathFragment(directory);
  Iterable<PathFragment> packagesUnderDirectory=recursivePackageProvider.getPackagesUnderDirectory(repository,pathFragment,excludedPathFragments);
  Iterable<PackageIdentifier> pkgIds=Iterables.transform(packagesUnderDirectory,new Function<PathFragment,PackageIdentifier>(){
    @Override public PackageIdentifier apply(    PathFragment path){
      return PackageIdentifier.create(repository,path);
    }
  }
);
  boolean foundTarget=false;
  for (  Iterable<PackageIdentifier> pkgIdBatch : Iterables.partition(pkgIds,MAX_PACKAGES_BULK_GET)) {
    Iterable<ResolvedTargets<Target>> resolvedTargets=bulkGetTargetsInPackage(originalPattern,pkgIdBatch,NO_FILTER).values();
    List<Target> filteredTargets=new ArrayList<>(calculateSize(resolvedTargets));
    for (    ResolvedTargets<Target> targets : resolvedTargets) {
      for (      Target target : targets.getTargets()) {
        foundTarget=true;
        if (actualPolicy.shouldRetain(target,false)) {
          filteredTargets.add(target);
        }
      }
    }
    callback.process(filteredTargets);
  }
  if (!foundTarget) {
    throw new TargetParsingException("no targets found beneath '" + pathFragment + "'");
  }
}
