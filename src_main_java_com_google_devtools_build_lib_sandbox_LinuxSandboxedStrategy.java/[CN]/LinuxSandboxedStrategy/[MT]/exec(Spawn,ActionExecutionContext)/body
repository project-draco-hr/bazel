{
  if (!spawn.isRemotable()) {
    standaloneStrategy.exec(spawn,actionExecutionContext);
    return;
  }
  Executor executor=actionExecutionContext.getExecutor();
  if (executor.reportsSubcommands()) {
    executor.reportSubcommand(Label.print(spawn.getOwner().getLabel()) + " [" + spawn.getResourceOwner().prettyPrint()+ "]",spawn.asShellCommand(executor.getExecRoot()));
  }
  executor.getEventBus().post(ActionStatusMessage.runningStrategy(spawn.getResourceOwner(),"sandbox"));
  FileOutErr outErr=actionExecutionContext.getFileOutErr();
  String execId=uuid + "-" + execCounter.getAndIncrement();
  Path sandboxPath=execRoot.getRelative(Constants.PRODUCT_NAME + "-sandbox").getRelative(execId);
  ImmutableMap<Path,Path> mounts;
  try {
    mounts=getMounts(spawn,actionExecutionContext);
  }
 catch (  IllegalArgumentException|IOException e) {
    throw new EnvironmentalExecException("Could not prepare mounts for sandbox execution",e);
  }
  ImmutableSet<Path> createDirs=createImportantDirs(spawn.getEnvironment());
  int timeout=getTimeout(spawn);
  ImmutableSet.Builder<PathFragment> outputFiles=ImmutableSet.<PathFragment>builder();
  for (  PathFragment optionalOutput : spawn.getOptionalOutputFiles()) {
    Preconditions.checkArgument(!optionalOutput.isAbsolute());
    outputFiles.add(optionalOutput);
  }
  for (  ActionInput output : spawn.getOutputFiles()) {
    outputFiles.add(new PathFragment(output.getExecPathString()));
  }
  try {
    final NamespaceSandboxRunner runner=new NamespaceSandboxRunner(execRoot,sandboxPath,mounts,createDirs,verboseFailures,sandboxDebug);
    try {
      runner.run(spawn.getArguments(),spawn.getEnvironment(),execRoot.getPathFile(),outErr,outputFiles.build(),timeout,!this.unblockNetwork && !spawn.getExecutionInfo().containsKey("requires-network"));
    }
  finally {
      backgroundWorkers.execute(new Runnable(){
        @Override public void run(){
          try {
            while (!Thread.currentThread().isInterrupted()) {
              try {
                runner.cleanup();
                return;
              }
 catch (              IOException e2) {
                Thread.sleep(250);
              }
            }
          }
 catch (          InterruptedException e) {
          }
        }
      }
);
    }
  }
 catch (  IOException e) {
    throw new UserExecException("I/O error during sandboxed execution",e);
  }
}
