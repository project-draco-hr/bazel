{
  ThreadPoolExecutor executor=new ThreadPoolExecutor(3,3,0,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
  final AtomicBoolean throwableSeen=new AtomicBoolean(false);
  ErrorHandler errorHandler=new ErrorHandler(){
    @Override public void handle(    Throwable t,    ErrorClassification classification){
      if (t == THROWABLE) {
        assertThat(classification).isEqualTo(ErrorClassification.CRITICAL);
        throwableSeen.compareAndSet(false,true);
      }
 else {
        fail();
      }
    }
  }
;
  final AbstractQueueVisitor visitor=createQueueVisitorWithConstantErrorClassification(executor,ErrorClassification.CRITICAL,errorHandler);
  final CountDownLatch latch1=new CountDownLatch(1);
  final AtomicBoolean wasInterrupted=new AtomicBoolean(false);
  Runnable r1=new Runnable(){
    @Override public void run(){
      latch1.countDown();
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        wasInterrupted.set(true);
      }
    }
  }
;
  visitor.execute(r1);
  latch1.await();
  visitor.execute(throwingRunnable());
  try {
    visitor.awaitQuiescence(true);
    fail();
  }
 catch (  Exception e) {
    assertSame(THROWABLE,e);
  }
  assertTrue(wasInterrupted.get());
  assertTrue(executor.isShutdown());
  assertTrue(throwableSeen.get());
}
