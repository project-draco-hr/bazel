{
  TargetPatternSequence targetPatternSequence=(TargetPatternSequence)skyKey.argument();
  Iterable<SkyKey> patternSkyKeys=TargetPatternValue.keys(targetPatternSequence.getPatterns(),targetPatternSequence.getPolicy(),targetPatternSequence.getOffset());
  Map<SkyKey,ValueOrException<TargetParsingException>> targetPatternValuesByKey=env.getValuesOrThrow(patternSkyKeys,TargetParsingException.class);
  if (env.valuesMissing()) {
    return null;
  }
  EventHandler eventHandler=env.getListener();
  boolean handlerIsParseFailureListener=eventHandler instanceof ParseFailureListener;
  ResolvedTargets.Builder<Label> builder=ResolvedTargets.builder();
  for (  SkyKey key : patternSkyKeys) {
    try {
      TargetPatternValue resultValue=Preconditions.checkNotNull((TargetPatternValue)targetPatternValuesByKey.get(key).get());
      ResolvedTargets<Label> results=resultValue.getTargets();
      if (((TargetPatternKey)key.argument()).isNegative()) {
        builder.filter(Predicates.not(Predicates.in(results.getTargets())));
      }
 else {
        builder.merge(results);
      }
    }
 catch (    TargetParsingException e) {
      handleTargetParsingException(eventHandler,handlerIsParseFailureListener,key,e);
    }
  }
  ResolvedTargets<Label> resolvedTargets=builder.build();
  List<SkyKey> targetKeys=new ArrayList<>();
  for (  Label target : resolvedTargets.getTargets()) {
    targetKeys.add(TransitiveTargetValue.key(target));
  }
  env.getValuesOrThrow(targetKeys,NoSuchPackageException.class,NoSuchTargetException.class);
  if (env.valuesMissing()) {
    return null;
  }
  return PrepareDepsOfPatternsValue.INSTANCE;
}
