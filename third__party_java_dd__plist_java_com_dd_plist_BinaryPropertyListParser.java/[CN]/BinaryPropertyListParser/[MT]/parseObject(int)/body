{
  int offset=offsetTable[obj];
  byte type=bytes[offset];
  int objType=(type & 0xF0) >> 4;
  int objInfo=(type & 0x0F);
switch (objType) {
case 0x0:
{
switch (objInfo) {
case 0x0:
{
          return null;
        }
case 0x8:
{
        return new NSNumber(false);
      }
case 0x9:
{
      return new NSNumber(true);
    }
case 0xC:
{
    break;
  }
case 0xD:
{
  break;
}
case 0xE:
{
break;
}
case 0xF:
{
return null;
}
}
break;
}
case 0x1:
{
int length=(int)Math.pow(2,objInfo);
if (length < Runtime.getRuntime().freeMemory()) {
return new NSNumber(copyOfRange(bytes,offset + 1,offset + 1 + length),NSNumber.INTEGER);
}
 else {
throw new OutOfMemoryError("To little heap space available! Wanted to read " + length + " bytes, but only "+ Runtime.getRuntime().freeMemory()+ " are available.");
}
}
case 0x2:
{
int length=(int)Math.pow(2,objInfo);
if (length < Runtime.getRuntime().freeMemory()) {
return new NSNumber(copyOfRange(bytes,offset + 1,offset + 1 + length),NSNumber.REAL);
}
 else {
throw new OutOfMemoryError("To little heap space available! Wanted to read " + length + " bytes, but only "+ Runtime.getRuntime().freeMemory()+ " are available.");
}
}
case 0x3:
{
if (objInfo != 0x3) {
throw new PropertyListFormatException("The given binary property list contains a date object of an unknown type (" + objInfo + ")");
}
return new NSDate(copyOfRange(bytes,offset + 1,offset + 9));
}
case 0x4:
{
int[] lenAndoffset=readLengthAndOffset(objInfo,offset);
int length=lenAndoffset[0];
int dataoffset=lenAndoffset[1];
if (length < Runtime.getRuntime().freeMemory()) {
return new NSData(copyOfRange(bytes,offset + dataoffset,offset + dataoffset + length));
}
 else {
throw new OutOfMemoryError("To little heap space available! Wanted to read " + length + " bytes, but only "+ Runtime.getRuntime().freeMemory()+ " are available.");
}
}
case 0x5:
{
int[] lenAndoffset=readLengthAndOffset(objInfo,offset);
int length=lenAndoffset[0];
int stroffset=lenAndoffset[1];
if (length < Runtime.getRuntime().freeMemory()) {
return new NSString(copyOfRange(bytes,offset + stroffset,offset + stroffset + length),"ASCII");
}
 else {
throw new OutOfMemoryError("To little heap space available! Wanted to read " + length + " bytes, but only "+ Runtime.getRuntime().freeMemory()+ " are available.");
}
}
case 0x6:
{
int[] lenAndoffset=readLengthAndOffset(objInfo,offset);
int length=lenAndoffset[0];
int stroffset=lenAndoffset[1];
length*=2;
if (length < Runtime.getRuntime().freeMemory()) {
return new NSString(copyOfRange(bytes,offset + stroffset,offset + stroffset + length),"UTF-16BE");
}
 else {
throw new OutOfMemoryError("To little heap space available! Wanted to read " + length + " bytes, but only "+ Runtime.getRuntime().freeMemory()+ " are available.");
}
}
case 0x8:
{
int length=objInfo + 1;
if (length < Runtime.getRuntime().freeMemory()) {
return new UID(String.valueOf(obj),copyOfRange(bytes,offset + 1,offset + 1 + length));
}
 else {
throw new OutOfMemoryError("To little heap space available! Wanted to read " + length + " bytes, but only "+ Runtime.getRuntime().freeMemory()+ " are available.");
}
}
case 0xA:
{
int[] lenAndoffset=readLengthAndOffset(objInfo,offset);
int length=lenAndoffset[0];
int arrayoffset=lenAndoffset[1];
if (length * objectRefSize > Runtime.getRuntime().freeMemory()) {
throw new OutOfMemoryError("To little heap space available!");
}
NSArray array=new NSArray(length);
for (int i=0; i < length; i++) {
int objRef=(int)parseUnsignedInt(copyOfRange(bytes,offset + arrayoffset + i * objectRefSize,offset + arrayoffset + (i + 1) * objectRefSize));
array.setValue(i,parseObject(objRef));
}
return array;
}
case 0xB:
{
int[] lenAndoffset=readLengthAndOffset(objInfo,offset);
int length=lenAndoffset[0];
int contentOffset=lenAndoffset[1];
if (length * objectRefSize > Runtime.getRuntime().freeMemory()) {
throw new OutOfMemoryError("To little heap space available!");
}
NSSet set=new NSSet(true);
for (int i=0; i < length; i++) {
int objRef=(int)parseUnsignedInt(copyOfRange(bytes,offset + contentOffset + i * objectRefSize,offset + contentOffset + (i + 1) * objectRefSize));
set.addObject(parseObject(objRef));
}
return set;
}
case 0xC:
{
int[] lenAndoffset=readLengthAndOffset(objInfo,offset);
int length=lenAndoffset[0];
int contentOffset=lenAndoffset[1];
if (length * objectRefSize > Runtime.getRuntime().freeMemory()) {
throw new OutOfMemoryError("To little heap space available!");
}
NSSet set=new NSSet();
for (int i=0; i < length; i++) {
int objRef=(int)parseUnsignedInt(copyOfRange(bytes,offset + contentOffset + i * objectRefSize,offset + contentOffset + (i + 1) * objectRefSize));
set.addObject(parseObject(objRef));
}
return set;
}
case 0xD:
{
int[] lenAndoffset=readLengthAndOffset(objInfo,offset);
int length=lenAndoffset[0];
int contentOffset=lenAndoffset[1];
if (length * 2 * objectRefSize > Runtime.getRuntime().freeMemory()) {
throw new OutOfMemoryError("To little heap space available!");
}
NSDictionary dict=new NSDictionary();
for (int i=0; i < length; i++) {
int keyRef=(int)parseUnsignedInt(copyOfRange(bytes,offset + contentOffset + i * objectRefSize,offset + contentOffset + (i + 1) * objectRefSize));
int valRef=(int)parseUnsignedInt(copyOfRange(bytes,offset + contentOffset + (length * objectRefSize)+ i * objectRefSize,offset + contentOffset + (length * objectRefSize)+ (i + 1) * objectRefSize));
NSObject key=parseObject(keyRef);
NSObject val=parseObject(valRef);
dict.put(key.toString(),val);
}
return dict;
}
default :
{
System.err.println("WARNING: The given binary property list contains an object of unknown type (" + objType + ")");
}
}
return null;
}
