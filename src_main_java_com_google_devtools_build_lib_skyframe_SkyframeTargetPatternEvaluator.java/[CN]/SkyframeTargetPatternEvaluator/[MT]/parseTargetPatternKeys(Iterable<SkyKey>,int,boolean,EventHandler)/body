{
  EvaluationResult<TargetPatternValue> result=skyframeExecutor.targetPatterns(patternSkyKeys,numThreads,keepGoing,eventHandler);
  String errorMessage=null;
  ResolvedTargets.Builder<Label> resolvedLabelsBuilder=ResolvedTargets.builder();
  for (  SkyKey key : patternSkyKeys) {
    TargetPatternValue resultValue=result.get(key);
    if (resultValue != null) {
      ResolvedTargets<Label> results=resultValue.getTargets();
      if (((TargetPatternValue.TargetPatternKey)key.argument()).isNegative()) {
        resolvedLabelsBuilder.filter(Predicates.not(Predicates.in(results.getTargets())));
      }
 else {
        resolvedLabelsBuilder.merge(results);
      }
    }
 else {
      TargetPatternValue.TargetPatternKey patternKey=(TargetPatternValue.TargetPatternKey)key.argument();
      String rawPattern=patternKey.getPattern();
      ErrorInfo error=result.errorMap().get(key);
      if (error == null) {
        Preconditions.checkState(!keepGoing);
        continue;
      }
      if (error.getException() != null) {
        errorMessage=error.getException().getMessage();
      }
 else       if (!Iterables.isEmpty(error.getCycleInfo())) {
        errorMessage="cycles detected during target parsing";
        skyframeExecutor.getCyclesReporter().reportCycles(error.getCycleInfo(),key,eventHandler);
      }
 else {
        throw new IllegalStateException(error.toString());
      }
      if (keepGoing) {
        eventHandler.handle(Event.error("Skipping '" + rawPattern + "': "+ errorMessage));
      }
      resolvedLabelsBuilder.setError();
      if (eventHandler instanceof ParseFailureListener) {
        ParseFailureListener parseListener=(ParseFailureListener)eventHandler;
        parseListener.parsingError(rawPattern,errorMessage);
      }
    }
  }
  if (!keepGoing && result.hasError()) {
    Preconditions.checkState(errorMessage != null,"unexpected errors: %s",result.errorMap());
    throw new TargetParsingException(errorMessage);
  }
  ResolvedTargets<Label> resolvedLabels=resolvedLabelsBuilder.build();
  Set<PackageIdentifier> packagesToRequest=new HashSet<>();
  for (  Label label : Iterables.concat(resolvedLabels.getTargets(),resolvedLabels.getFilteredTargets())) {
    packagesToRequest.add(label.getPackageIdentifier());
  }
  WalkableGraph walkableGraph=Preconditions.checkNotNull(result.getWalkableGraph(),result);
  Map<PackageIdentifier,Package> packages=getPackages(packagesToRequest,walkableGraph);
  ResolvedTargets.Builder<Target> resolvedTargetsBuilder=ResolvedTargets.builder();
  if (resolvedLabels.hasError()) {
    resolvedTargetsBuilder.setError();
  }
  for (  Label label : resolvedLabels.getTargets()) {
    resolvedTargetsBuilder.add(getExistingTarget(label,packages));
  }
  for (  Label label : resolvedLabels.getFilteredTargets()) {
    resolvedTargetsBuilder.remove(getExistingTarget(label,packages));
  }
  return resolvedTargetsBuilder.build();
}
