{
  enableAnalysis(true);
  EvaluationResult<ConfiguredTargetValue> result;
  try {
    result=skyframeExecutor.configureTargets(values,keepGoing);
  }
  finally {
    enableAnalysis(false);
  }
  ImmutableMap<Action,ConflictException> badActions=skyframeExecutor.findArtifactConflicts();
  Collection<ConfiguredTarget> goodCts=Lists.newArrayListWithCapacity(values.size());
  for (  ConfiguredTargetKey value : values) {
    ConfiguredTargetValue ctValue=result.get(ConfiguredTargetValue.key(value));
    if (ctValue == null) {
      continue;
    }
    goodCts.add(ctValue.getConfiguredTarget());
  }
  if (!result.hasError() && badActions.isEmpty()) {
    setDeserializedArtifactOwners();
    return goodCts;
  }
  if (!keepGoing) {
    for (    Map.Entry<Action,ConflictException> bad : badActions.entrySet()) {
      ConflictException ex=bad.getValue();
      try {
        ex.rethrowTyped();
      }
 catch (      MutableActionGraph.ActionConflictException ace) {
        ace.reportTo(skyframeExecutor.getReporter());
        String errorMsg="Analysis of target '" + bad.getKey().getOwner().getLabel() + "' failed; build aborted";
        throw new ViewCreationFailedException(errorMsg);
      }
catch (      ArtifactPrefixConflictException apce) {
        skyframeExecutor.getReporter().handle(Event.error(apce.getMessage()));
      }
      throw new ViewCreationFailedException(ex.getMessage());
    }
    Map.Entry<SkyKey,ErrorInfo> error=result.errorMap().entrySet().iterator().next();
    SkyKey topLevel=error.getKey();
    ErrorInfo errorInfo=error.getValue();
    assertSaneAnalysisError(errorInfo,topLevel);
    skyframeExecutor.getCyclesReporter().reportCycles(errorInfo.getCycleInfo(),topLevel,skyframeExecutor.getReporter());
    Throwable cause=errorInfo.getException();
    Preconditions.checkState(cause != null || !Iterables.isEmpty(errorInfo.getCycleInfo()),errorInfo);
    String errorMsg="Analysis of target '" + ConfiguredTargetValue.extractLabel(topLevel) + "' failed; build aborted";
    if (cause instanceof ActionConflictException) {
      ((ActionConflictException)cause).reportTo(skyframeExecutor.getReporter());
    }
    throw new ViewCreationFailedException(errorMsg);
  }
  for (  Map.Entry<SkyKey,ErrorInfo> errorEntry : result.errorMap().entrySet()) {
    if (values.contains(errorEntry.getKey().argument())) {
      SkyKey errorKey=errorEntry.getKey();
      ConfiguredTargetKey label=(ConfiguredTargetKey)errorKey.argument();
      ErrorInfo errorInfo=errorEntry.getValue();
      assertSaneAnalysisError(errorInfo,errorKey);
      skyframeExecutor.getCyclesReporter().reportCycles(errorInfo.getCycleInfo(),errorKey,skyframeExecutor.getReporter());
      Label root;
      if (!Iterables.isEmpty(errorEntry.getValue().getRootCauses())) {
        SkyKey culprit=Preconditions.checkNotNull(Iterables.getFirst(errorEntry.getValue().getRootCauses(),null));
        root=((ConfiguredTargetKey)culprit.argument()).getLabel();
      }
 else {
        root=maybeGetConfiguredTargetCycleCulprit(errorInfo.getCycleInfo());
      }
      Exception cause=errorInfo.getException();
      if (cause instanceof ActionConflictException) {
        ((ActionConflictException)cause).reportTo(skyframeExecutor.getReporter());
      }
      skyframeExecutor.getReporter().handle(Event.warn("errors encountered while analyzing target '" + label + "': it will not be built"));
      eventBus.post(new AnalysisFailureEvent(LabelAndConfiguration.of(label.getLabel(),label.getConfiguration()),root));
    }
  }
  Collection<Exception> reportedExceptions=Sets.newHashSet();
  for (  Map.Entry<Action,ConflictException> bad : badActions.entrySet()) {
    ConflictException ex=bad.getValue();
    try {
      ex.rethrowTyped();
    }
 catch (    MutableActionGraph.ActionConflictException ace) {
      ace.reportTo(skyframeExecutor.getReporter());
      skyframeExecutor.getReporter().handle(Event.warn("errors encountered while analyzing target '" + bad.getKey().getOwner().getLabel() + "': it will not be built"));
    }
catch (    ArtifactPrefixConflictException apce) {
      if (reportedExceptions.add(apce)) {
        skyframeExecutor.getReporter().handle(Event.error(apce.getMessage()));
      }
    }
  }
  if (!badActions.isEmpty()) {
    EvaluationResult<PostConfiguredTargetValue> actionConflictResult=skyframeExecutor.postConfigureTargets(values,keepGoing,badActions);
    goodCts=Lists.newArrayListWithCapacity(values.size());
    for (    ConfiguredTargetKey value : values) {
      PostConfiguredTargetValue postCt=actionConflictResult.get(PostConfiguredTargetValue.key(value));
      if (postCt != null) {
        goodCts.add(postCt.getCt());
      }
    }
  }
  setDeserializedArtifactOwners();
  return goodCts;
}
