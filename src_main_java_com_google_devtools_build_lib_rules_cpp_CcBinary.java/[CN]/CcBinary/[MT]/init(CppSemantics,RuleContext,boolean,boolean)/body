{
  ruleContext.checkSrcsSamePackage(true);
  FeatureConfiguration featureConfiguration=CcCommon.configureFeatures(ruleContext);
  CcCommon common=new CcCommon(ruleContext);
  CppConfiguration cppConfiguration=ruleContext.getFragment(CppConfiguration.class);
  PrecompiledFiles precompiledFiles=new PrecompiledFiles(ruleContext);
  LinkTargetType linkType=isLinkShared(ruleContext) ? LinkTargetType.DYNAMIC_LIBRARY : LinkTargetType.EXECUTABLE;
  List<String> linkopts=common.getLinkopts();
  LinkStaticness linkStaticness=getLinkStaticness(ruleContext,linkopts,cppConfiguration);
  CcLibraryHelper helper=new CcLibraryHelper(ruleContext,semantics,featureConfiguration).fromCommon(common).addSources(common.getSources()).addDeps(ImmutableList.of(CppHelper.mallocForTarget(ruleContext))).setFake(fake).setLinkType(linkType).addPrecompiledFiles(precompiledFiles);
  CcLibraryHelper.Info info=helper.build();
  CppCompilationContext cppCompilationContext=info.getCppCompilationContext();
  CcCompilationOutputs ccCompilationOutputs=info.getCcCompilationOutputs();
  PathFragment binaryPath=new PathFragment(ruleContext.getTarget().getName() + OsUtils.executableExtension());
  Artifact binary=ruleContext.getPackageRelativeArtifact(binaryPath,ruleContext.getConfiguration().getBinDirectory());
  CppLinkAction.Builder linkActionBuilder=determineLinkerArguments(ruleContext,common,precompiledFiles,ccCompilationOutputs,cppCompilationContext.getCompilationPrerequisites(),fake,binary,linkStaticness,linkopts);
  linkActionBuilder.setUseTestOnlyFlags(useTestOnlyFlags);
  linkActionBuilder.addNonLibraryInputs(ccCompilationOutputs.getHeaderTokenFiles());
  CcToolchainProvider ccToolchain=CppHelper.getToolchain(ruleContext);
  if (linkStaticness == LinkStaticness.DYNAMIC) {
    linkActionBuilder.setRuntimeInputs(ccToolchain.getDynamicRuntimeLinkMiddleman(),ccToolchain.getDynamicRuntimeLinkInputs());
  }
 else {
    linkActionBuilder.setRuntimeInputs(ccToolchain.getStaticRuntimeLinkMiddleman(),ccToolchain.getStaticRuntimeLinkInputs());
    if (!ccToolchain.getStaticRuntimeLinkInputs().isEmpty()) {
      linkActionBuilder.addLinkopt("-static-libgcc");
    }
  }
  linkActionBuilder.setLinkType(linkType);
  linkActionBuilder.setLinkStaticness(linkStaticness);
  linkActionBuilder.setFake(fake);
  if (CppLinkAction.enableSymbolsCounts(cppConfiguration,fake,linkType)) {
    linkActionBuilder.setSymbolCountsOutput(ruleContext.getPackageRelativeArtifact(CppLinkAction.symbolCountsFileName(binaryPath),ruleContext.getConfiguration().getBinDirectory()));
  }
  CppLinkAction.Context linkContext=new CppLinkAction.Context(linkActionBuilder);
  if (featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)) {
    linkActionBuilder.setLTOIndexing(true);
    CppLinkAction indexAction=linkActionBuilder.build();
    ruleContext.registerAction(indexAction);
    for (    LTOBackendArtifacts ltoArtifacts : indexAction.getAllLTOBackendArtifacts()) {
      ltoArtifacts.scheduleLTOBackendAction(ruleContext);
    }
    linkActionBuilder.setLTOIndexing(false);
  }
  CppLinkAction linkAction=linkActionBuilder.build();
  ruleContext.registerAction(linkAction);
  LibraryToLink outputLibrary=linkAction.getOutputLibrary();
  Iterable<Artifact> fakeLinkerInputs=fake ? linkAction.getInputs() : ImmutableList.<Artifact>of();
  Artifact executable=outputLibrary.getArtifact();
  CcLinkingOutputs.Builder linkingOutputsBuilder=new CcLinkingOutputs.Builder();
  if (isLinkShared(ruleContext)) {
    if (CppFileTypes.SHARED_LIBRARY.matches(binary.getFilename())) {
      linkingOutputsBuilder.addDynamicLibrary(outputLibrary);
      linkingOutputsBuilder.addExecutionDynamicLibrary(outputLibrary);
    }
 else {
      ruleContext.attributeError("linkshared","'linkshared' used in non-shared library");
    }
  }
  for (  Artifact library : precompiledFiles.getSharedLibraries()) {
    LibraryToLink symlink=common.getDynamicLibrarySymlink(library,true);
    linkingOutputsBuilder.addDynamicLibrary(symlink);
    linkingOutputsBuilder.addExecutionDynamicLibrary(symlink);
  }
  CcLinkingOutputs linkingOutputs=linkingOutputsBuilder.build();
  NestedSet<Artifact> filesToBuild=NestedSetBuilder.create(Order.STABLE_ORDER,executable);
  Artifact strippedFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_STRIPPED);
  CppHelper.createStripAction(ruleContext,cppConfiguration,executable,strippedFile);
  DwoArtifactsCollector dwoArtifacts=collectTransitiveDwoArtifacts(ruleContext,ccCompilationOutputs,linkStaticness);
  Artifact dwpFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_DEBUG_PACKAGE);
  createDebugPackagerActions(ruleContext,cppConfiguration,dwpFile,dwoArtifacts);
  Artifact explicitDwpFile=dwpFile;
  if (!cppConfiguration.useFission()) {
    explicitDwpFile=null;
  }
 else {
    if (TargetUtils.isTestRule(ruleContext.getRule()) && linkStaticness != LinkStaticness.DYNAMIC && cppConfiguration.shouldBuildTestDwp()) {
      filesToBuild=NestedSetBuilder.fromNestedSet(filesToBuild).add(dwpFile).build();
    }
  }
  Runfiles runfiles=collectRunfiles(ruleContext,linkingOutputs,cppCompilationContext,linkStaticness,filesToBuild,fakeLinkerInputs,fake,helper.getCompilationUnitSources());
  RunfilesSupport runfilesSupport=RunfilesSupport.withExecutable(ruleContext,runfiles,executable,ruleContext.getConfiguration().buildRunfiles());
  TransitiveLipoInfoProvider transitiveLipoInfo;
  if (cppConfiguration.isLipoContextCollector()) {
    transitiveLipoInfo=common.collectTransitiveLipoLabels(ccCompilationOutputs);
  }
 else {
    transitiveLipoInfo=TransitiveLipoInfoProvider.EMPTY;
  }
  RuleConfiguredTargetBuilder ruleBuilder=new RuleConfiguredTargetBuilder(ruleContext);
  addTransitiveInfoProviders(ruleContext,cppConfiguration,common,ruleBuilder,filesToBuild,ccCompilationOutputs,cppCompilationContext,linkingOutputs,dwoArtifacts,transitiveLipoInfo,fake);
  Map<Artifact,IncludeScannable> scannableMap=new LinkedHashMap<>();
  if (cppConfiguration.isLipoContextCollector()) {
    for (    IncludeScannable scannable : transitiveLipoInfo.getTransitiveIncludeScannables()) {
      Artifact source=Iterables.getOnlyElement(scannable.getIncludeScannerSources());
      scannableMap.put(source,scannable);
    }
  }
  return ruleBuilder.add(RunfilesProvider.class,RunfilesProvider.simple(runfiles)).add(CppDebugPackageProvider.class,new CppDebugPackageProvider(ruleContext.getLabel(),strippedFile,executable,explicitDwpFile)).setRunfilesSupport(runfilesSupport,executable).addProvider(LipoContextProvider.class,new LipoContextProvider(cppCompilationContext,ImmutableMap.copyOf(scannableMap))).addProvider(CppLinkAction.Context.class,linkContext).addSkylarkTransitiveInfo(CcSkylarkApiProvider.NAME,new CcSkylarkApiProvider()).build();
}
