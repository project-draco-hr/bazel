{
  if (!state.isDirty()) {
    return DirtyOutcome.NEEDS_EVALUATION;
  }
switch (state.getDirtyState()) {
case CHECK_DEPENDENCIES:
    Collection<SkyKey> directDepsToCheck=state.getNextDirtyDirectDeps();
  if (invalidatedByErrorTransience(directDepsToCheck,state)) {
    state.forceRebuild();
    graph.get(ErrorTransienceValue.key()).removeReverseDep(skyKey);
    return DirtyOutcome.NEEDS_EVALUATION;
  }
if (!keepGoing) {
  Map<SkyKey,NodeEntry> entriesToCheck=graph.getBatch(directDepsToCheck);
  for (  Map.Entry<SkyKey,NodeEntry> entry : entriesToCheck.entrySet()) {
    if (entry.getValue().isDone() && entry.getValue().getErrorInfo() != null) {
      SkyKey errorKey=entry.getKey();
      NodeEntry errorEntry=entry.getValue();
      state.addTemporaryDirectDeps(GroupedListHelper.create(ImmutableList.of(errorKey)));
      errorEntry.checkIfDoneForDirtyReverseDep(skyKey);
      for (      Map.Entry<SkyKey,NodeEntry> depEntry : entriesToCheck.entrySet()) {
        if (!depEntry.getKey().equals(errorKey)) {
          depEntry.getValue().removeReverseDep(skyKey);
        }
      }
      if (!visitor.preventNewEvaluations()) {
        return DirtyOutcome.ALREADY_PROCESSED;
      }
      throw SchedulerException.ofError(errorEntry.getErrorInfo(),entry.getKey());
    }
  }
}
state.addTemporaryDirectDeps(GroupedListHelper.create(directDepsToCheck));
for (SkyKey directDep : directDepsToCheck) {
enqueueChild(skyKey,state,directDep,true);
}
return DirtyOutcome.ALREADY_PROCESSED;
case VERIFIED_CLEAN:
visitor.notifyDone(skyKey);
Set<SkyKey> reverseDeps=state.markClean();
if (progressReceiver != null) {
progressReceiver.evaluated(skyKey,new SkyValueSupplier(state),EvaluationState.CLEAN);
}
if (!keepGoing && state.getErrorInfo() != null) {
if (!visitor.preventNewEvaluations()) {
return DirtyOutcome.ALREADY_PROCESSED;
}
throw SchedulerException.ofError(state.getErrorInfo(),skyKey);
}
signalValuesAndEnqueueIfReady(visitor,reverseDeps,state.getVersion());
return DirtyOutcome.ALREADY_PROCESSED;
case NEEDS_REBUILDING:
maybeMarkRebuildingAndRemoveRemainingDirtyDirectDeps(skyKey,state);
case REBUILDING:
return DirtyOutcome.NEEDS_EVALUATION;
default :
throw new IllegalStateException("key: " + skyKey + ", entry: "+ state);
}
}
