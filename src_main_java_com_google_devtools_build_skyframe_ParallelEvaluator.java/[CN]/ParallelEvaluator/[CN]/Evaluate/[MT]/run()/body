{
  NodeEntry state=graph.get(skyKey);
  Preconditions.checkNotNull(state,"%s %s",skyKey,state);
  Preconditions.checkState(state.isReady(),"%s %s",skyKey,state);
  if (state.isDirty()) {
switch (state.getDirtyState()) {
case CHECK_DEPENDENCIES:
      Collection<SkyKey> directDepsToCheck=state.getNextDirtyDirectDeps();
    if (invalidatedByErrorTransience(directDepsToCheck,state)) {
      state.forceRebuild();
      break;
    }
  if (!keepGoing) {
    for (    Map.Entry<SkyKey,NodeEntry> entry : graph.getBatch(directDepsToCheck).entrySet()) {
      if (entry.getValue().isDone() && entry.getValue().getErrorInfo() != null) {
        if (!visitor.preventNewEvaluations()) {
          return;
        }
        SkyKey errorKey=entry.getKey();
        NodeEntry errorEntry=entry.getValue();
        state.addTemporaryDirectDeps(GroupedListHelper.create(ImmutableList.of(errorKey)));
        DependencyState errorState=entry.getValue().addReverseDepAndCheckIfDone(skyKey);
        Preconditions.checkState(errorState == DependencyState.DONE,"%s %s %s %s",skyKey,state,errorKey,errorEntry);
        throw SchedulerException.ofError(errorEntry.getErrorInfo(),entry.getKey());
      }
    }
  }
state.addTemporaryDirectDeps(GroupedListHelper.create(directDepsToCheck));
for (SkyKey directDep : directDepsToCheck) {
enqueueChild(skyKey,state,directDep);
}
return;
case VERIFIED_CLEAN:
visitor.notifyDone(skyKey);
Set<SkyKey> reverseDeps=state.markClean();
if (progressReceiver != null) {
progressReceiver.evaluated(skyKey,new SkyValueSupplier(state),EvaluationState.CLEAN);
}
if (!keepGoing && state.getErrorInfo() != null) {
if (!visitor.preventNewEvaluations()) {
return;
}
throw SchedulerException.ofError(state.getErrorInfo(),skyKey);
}
signalValuesAndEnqueueIfReady(visitor,reverseDeps,state.getVersion());
return;
case REBUILDING:
}
}
Set<SkyKey> directDeps=state.getTemporaryDirectDeps();
Preconditions.checkState(!directDeps.contains(ErrorTransienceValue.key()),"%s cannot have a dep on ErrorTransienceValue during building: %s",skyKey,state);
SkyFunctionEnvironment env=new SkyFunctionEnvironment(skyKey,directDeps,visitor);
SkyFunctionName functionName=skyKey.functionName();
SkyFunction factory=skyFunctions.get(functionName);
Preconditions.checkState(factory != null,"%s %s",functionName,state);
SkyValue value=null;
Profiler.instance().startTask(ProfilerTask.SKYFUNCTION,skyKey);
try {
value=factory.compute(skyKey,env);
}
 catch (final SkyFunctionException builderException) {
ReifiedSkyFunctionException reifiedBuilderException=new ReifiedSkyFunctionException(builderException,skyKey);
if (reifiedBuilderException.getRootCauseSkyKey().equals(skyKey)) {
boolean shouldFailFast=!keepGoing || builderException.isCatastrophic();
if (shouldFailFast) {
if (!visitor.preventNewEvaluations()) {
return;
}
}
registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,env);
ErrorInfo errorInfo=new ErrorInfo(reifiedBuilderException);
env.setError(errorInfo);
env.commit(keepGoing);
if (!shouldFailFast) {
return;
}
throw SchedulerException.ofError(errorInfo,skyKey);
}
}
catch (InterruptedException ie) {
throw SchedulerException.ofInterruption(ie,skyKey);
}
catch (RuntimeException re) {
String msg=prepareCrashMessage(skyKey,state.getInProgressReverseDeps());
throw new RuntimeException(msg,re);
}
 finally {
env.doneBuilding();
Profiler.instance().completeTask(ProfilerTask.SKYFUNCTION);
}
GroupedListHelper<SkyKey> newDirectDeps=env.newlyRequestedDeps;
if (value != null) {
Preconditions.checkState(!env.valuesMissing(),"%s -> %s, ValueEntry: %s",skyKey,newDirectDeps,state);
env.setValue(value);
registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,env);
env.commit(true);
return;
}
if (env.getDepErrorKey() != null) {
Preconditions.checkState(!keepGoing,"%s %s %s",skyKey,state,env.getDepErrorKey());
SkyKey childErrorKey=env.getDepErrorKey();
NodeEntry childErrorEntry=Preconditions.checkNotNull(graph.get(childErrorKey),"skyKey: %s, state: %s childErrorKey: %s",skyKey,state,childErrorKey);
if (!state.getTemporaryDirectDeps().contains(childErrorKey)) {
Preconditions.checkState(newDirectDeps.contains(childErrorKey),"%s %s %s",state,childErrorKey,newDirectDeps);
state.addTemporaryDirectDeps(GroupedListHelper.create(ImmutableList.of(childErrorKey)));
DependencyState childErrorState=childErrorEntry.addReverseDepAndCheckIfDone(skyKey);
Preconditions.checkState(childErrorState == DependencyState.DONE,"skyKey: %s, state: %s childErrorKey: %s",skyKey,state,childErrorKey,childErrorEntry);
}
 else {
Preconditions.checkState(!newDirectDeps.contains(childErrorKey),"%s %s %s",state,childErrorKey,newDirectDeps);
Preconditions.checkState(childErrorEntry.isDone(),"skyKey: %s, state: %s childErrorKey: %s",skyKey,state,childErrorKey,childErrorEntry);
}
ErrorInfo childErrorInfo=Preconditions.checkNotNull(childErrorEntry.getErrorInfo());
throw SchedulerException.ofError(childErrorInfo,childErrorKey);
}
state.addTemporaryDirectDeps(newDirectDeps);
if (newDirectDeps.isEmpty()) {
Preconditions.checkState(!env.childErrorInfos.isEmpty(),"%s %s",skyKey,state);
env.commit(keepGoing);
if (!keepGoing) {
throw SchedulerException.ofError(state.getErrorInfo(),skyKey);
}
return;
}
for (SkyKey newDirectDep : newDirectDeps) {
enqueueChild(skyKey,state,newDirectDep);
}
}
