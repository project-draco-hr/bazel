{
  NodeEntry state=Preconditions.checkNotNull(graph.get(null,Reason.EVALUATION,skyKey),skyKey);
  Preconditions.checkState(state.isReady(),"%s %s",skyKey,state);
  if (maybeHandleDirtyNode(state) == DirtyOutcome.ALREADY_PROCESSED) {
    return;
  }
  Set<SkyKey> oldDeps=state.getAllRemainingDirtyDirectDeps();
  SkyFunctionEnvironment env=new SkyFunctionEnvironment(skyKey,state.getTemporaryDirectDeps(),oldDeps,visitor);
  SkyFunctionName functionName=skyKey.functionName();
  SkyFunction factory=skyFunctions.get(functionName);
  Preconditions.checkState(factory != null,"Unable to find SkyFunction '%s' for node with key %s, %s",functionName,skyKey,state);
  SkyValue value=null;
  long startTime=BlazeClock.instance().nanoTime();
  try {
    value=factory.compute(skyKey,env);
  }
 catch (  final SkyFunctionException builderException) {
    ReifiedSkyFunctionException reifiedBuilderException=new ReifiedSkyFunctionException(builderException,skyKey);
    if ((!keepGoing || !env.valuesMissing()) && reifiedBuilderException.getRootCauseSkyKey().equals(skyKey)) {
      boolean shouldFailFast=!keepGoing || builderException.isCatastrophic();
      if (shouldFailFast) {
        if (!visitor.preventNewEvaluations()) {
          return;
        }
      }
      Map<SkyKey,NodeEntry> newlyRequestedDeps=getBatchValues(skyKey,Reason.RDEP_ADDITION,env.newlyRequestedDeps);
      boolean isTransitivelyTransient=reifiedBuilderException.isTransient();
      for (      NodeEntry depEntry : Iterables.concat(env.directDeps.values(),newlyRequestedDeps.values())) {
        if (!isDoneForBuild(depEntry)) {
          continue;
        }
        ErrorInfo depError=depEntry.getErrorInfo();
        if (depError != null) {
          isTransitivelyTransient|=depError.isTransient();
        }
      }
      ErrorInfo errorInfo=ErrorInfo.fromException(reifiedBuilderException,isTransitivelyTransient);
      registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,newlyRequestedDeps,oldDeps,env);
      env.setError(state,errorInfo,reifiedBuilderException.isTransient());
      env.commit(state,keepGoing);
      if (!shouldFailFast) {
        return;
      }
      throw SchedulerException.ofError(errorInfo,skyKey);
    }
  }
catch (  InterruptedException ie) {
    throw SchedulerException.ofInterruption(ie,skyKey);
  }
catch (  RuntimeException re) {
    String msg=prepareCrashMessage(skyKey,state.getInProgressReverseDeps());
    RuntimeException ex=new RuntimeException(msg,re);
    visitor.noteCrash(ex);
    throw ex;
  }
 finally {
    env.doneBuilding();
    long elapsedTimeNanos=BlazeClock.instance().nanoTime() - startTime;
    if (elapsedTimeNanos > 0) {
      if (progressReceiver != null) {
        progressReceiver.computed(skyKey,elapsedTimeNanos);
      }
      Profiler.instance().logSimpleTaskDuration(startTime,elapsedTimeNanos,ProfilerTask.SKYFUNCTION,skyKey);
    }
  }
  GroupedListHelper<SkyKey> newDirectDeps=env.newlyRequestedDeps;
  if (value != null) {
    Preconditions.checkState(!env.valuesMissing(),"Evaluation of %s returned non-null value " + "but requested dependencies that weren't computed yet (one of %s), ValueEntry: %s",skyKey,newDirectDeps,state);
    env.setValue(value);
    registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,graph.getBatch(skyKey,Reason.RDEP_ADDITION,env.newlyRequestedDeps),oldDeps,env);
    env.commit(state,true);
    return;
  }
  if (env.getDepErrorKey() != null) {
    Preconditions.checkState(!keepGoing,"%s %s %s",skyKey,state,env.getDepErrorKey());
    SkyKey childErrorKey=env.getDepErrorKey();
    NodeEntry childErrorEntry=Preconditions.checkNotNull(graph.get(skyKey,Reason.OTHER,childErrorKey),"skyKey: %s, state: %s childErrorKey: %s",skyKey,state,childErrorKey);
    if (newDirectDeps.contains(childErrorKey)) {
      state.addTemporaryDirectDeps(GroupedListHelper.create(ImmutableList.of(childErrorKey)));
      DependencyState childErrorState;
      if (oldDeps.contains(childErrorKey)) {
        childErrorState=childErrorEntry.checkIfDoneForDirtyReverseDep(skyKey);
      }
 else {
        childErrorState=childErrorEntry.addReverseDepAndCheckIfDone(skyKey);
      }
      Preconditions.checkState(childErrorState == DependencyState.DONE,"skyKey: %s, state: %s childErrorKey: %s",skyKey,state,childErrorKey,childErrorEntry);
    }
    ErrorInfo childErrorInfo=Preconditions.checkNotNull(childErrorEntry.getErrorInfo());
    visitor.preventNewEvaluations();
    throw SchedulerException.ofError(childErrorInfo,childErrorKey);
  }
  state.addTemporaryDirectDeps(newDirectDeps);
  if (newDirectDeps.isEmpty()) {
    Preconditions.checkState(!env.childErrorInfos.isEmpty(),"Evaluation of SkyKey failed and no dependencies were requested: %s %s",skyKey,state);
    Preconditions.checkState(keepGoing,"nokeep_going evaluation should have failed on first child error: %s %s %s",skyKey,state,env.childErrorInfos);
    env.commit(state,true);
    return;
  }
  for (  Map.Entry<SkyKey,NodeEntry> e : graph.createIfAbsentBatch(skyKey,Reason.ENQUEUING_CHILD,newDirectDeps).entrySet()) {
    SkyKey newDirectDep=e.getKey();
    NodeEntry newDirectDepEntry=e.getValue();
    enqueueChild(skyKey,state,newDirectDep,newDirectDepEntry,oldDeps.contains(newDirectDep));
  }
}
