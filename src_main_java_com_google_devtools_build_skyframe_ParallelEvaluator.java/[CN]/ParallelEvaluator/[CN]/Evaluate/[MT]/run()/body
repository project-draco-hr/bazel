{
  NodeEntry state=Preconditions.checkNotNull(graph.get(skyKey),skyKey);
  Preconditions.checkState(state.isReady(),"%s %s",skyKey,state);
  if (maybeHandleDirtyNode(state) == DirtyOutcome.ALREADY_PROCESSED) {
    return;
  }
  Set<SkyKey> directDeps=state.getTemporaryDirectDeps();
  Preconditions.checkState(!directDeps.contains(ErrorTransienceValue.key()),"%s cannot have a dep on ErrorTransienceValue during building: %s",skyKey,state);
  SkyFunctionEnvironment env=new SkyFunctionEnvironment(skyKey,directDeps,visitor);
  SkyFunctionName functionName=skyKey.functionName();
  SkyFunction factory=skyFunctions.get(functionName);
  Preconditions.checkState(factory != null,"%s %s",functionName,state);
  SkyValue value=null;
  long startTime=Profiler.nanoTimeMaybe();
  try {
    value=factory.compute(skyKey,env);
  }
 catch (  final SkyFunctionException builderException) {
    ReifiedSkyFunctionException reifiedBuilderException=new ReifiedSkyFunctionException(builderException,skyKey);
    if (reifiedBuilderException.getRootCauseSkyKey().equals(skyKey)) {
      boolean shouldFailFast=!keepGoing || builderException.isCatastrophic();
      if (shouldFailFast) {
        if (!visitor.preventNewEvaluations()) {
          return;
        }
      }
      registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,env);
      ErrorInfo errorInfo=ErrorInfo.fromException(reifiedBuilderException);
      env.setError(errorInfo);
      env.commit(keepGoing);
      if (!shouldFailFast) {
        return;
      }
      throw SchedulerException.ofError(errorInfo,skyKey);
    }
  }
catch (  InterruptedException ie) {
    throw SchedulerException.ofInterruption(ie,skyKey);
  }
catch (  RuntimeException re) {
    String msg=prepareCrashMessage(skyKey,state.getInProgressReverseDeps());
    throw new RuntimeException(msg,re);
  }
 finally {
    env.doneBuilding();
    long elapsedTimeNanos=Profiler.nanoTimeMaybe() - startTime;
    if (elapsedTimeNanos > 0) {
      if (progressReceiver != null) {
        progressReceiver.computed(skyKey,elapsedTimeNanos);
      }
      Profiler.instance().logSimpleTaskDuration(startTime,elapsedTimeNanos,ProfilerTask.SKYFUNCTION,skyKey);
    }
  }
  GroupedListHelper<SkyKey> newDirectDeps=env.newlyRequestedDeps;
  if (value != null) {
    Preconditions.checkState(!env.valuesMissing(),"%s -> %s, ValueEntry: %s",skyKey,newDirectDeps,state);
    env.setValue(value);
    registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,env);
    env.commit(true);
    return;
  }
  if (env.getDepErrorKey() != null) {
    Preconditions.checkState(!keepGoing,"%s %s %s",skyKey,state,env.getDepErrorKey());
    SkyKey childErrorKey=env.getDepErrorKey();
    NodeEntry childErrorEntry=Preconditions.checkNotNull(graph.get(childErrorKey),"skyKey: %s, state: %s childErrorKey: %s",skyKey,state,childErrorKey);
    if (!state.getTemporaryDirectDeps().contains(childErrorKey)) {
      Preconditions.checkState(newDirectDeps.contains(childErrorKey),"%s %s %s",state,childErrorKey,newDirectDeps);
      state.addTemporaryDirectDeps(GroupedListHelper.create(ImmutableList.of(childErrorKey)));
      DependencyState childErrorState=childErrorEntry.addReverseDepAndCheckIfDone(skyKey);
      Preconditions.checkState(childErrorState == DependencyState.DONE,"skyKey: %s, state: %s childErrorKey: %s",skyKey,state,childErrorKey,childErrorEntry);
    }
 else {
      Preconditions.checkState(!newDirectDeps.contains(childErrorKey),"%s %s %s",state,childErrorKey,newDirectDeps);
      Preconditions.checkState(childErrorEntry.isDone(),"skyKey: %s, state: %s childErrorKey: %s",skyKey,state,childErrorKey,childErrorEntry);
    }
    ErrorInfo childErrorInfo=Preconditions.checkNotNull(childErrorEntry.getErrorInfo());
    throw SchedulerException.ofError(childErrorInfo,childErrorKey);
  }
  state.addTemporaryDirectDeps(newDirectDeps);
  if (newDirectDeps.isEmpty()) {
    Preconditions.checkState(!env.childErrorInfos.isEmpty(),"%s %s",skyKey,state);
    env.commit(keepGoing);
    if (!keepGoing) {
      throw SchedulerException.ofError(state.getErrorInfo(),skyKey);
    }
    return;
  }
  for (  Map.Entry<SkyKey,NodeEntry> e : graph.createIfAbsentBatch(newDirectDeps).entrySet()) {
    SkyKey newDirectDep=e.getKey();
    NodeEntry newDirectDepEntry=e.getValue();
    enqueueChild(skyKey,state,newDirectDep,newDirectDepEntry,false);
  }
}
