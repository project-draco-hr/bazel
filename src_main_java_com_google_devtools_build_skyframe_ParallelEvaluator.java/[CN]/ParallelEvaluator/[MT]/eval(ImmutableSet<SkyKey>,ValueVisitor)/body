{
  NodeEntry errorTransienceEntry=Iterables.getOnlyElement(graph.createIfAbsentBatch(ImmutableList.of(ErrorTransienceValue.KEY)).values());
  if (!errorTransienceEntry.isDone()) {
    injectValues(ImmutableMap.of(ErrorTransienceValue.KEY,(SkyValue)ErrorTransienceValue.INSTANCE),graphVersion,graph,dirtyKeyTracker);
  }
  for (  Map.Entry<SkyKey,NodeEntry> e : graph.createIfAbsentBatch(skyKeys).entrySet()) {
    SkyKey skyKey=e.getKey();
    NodeEntry entry=e.getValue();
switch (entry.addReverseDepAndCheckIfDone(null)) {
case NEEDS_SCHEDULING:
      visitor.enqueueEvaluation(skyKey);
    break;
case DONE:
  informProgressReceiverThatValueIsDone(skyKey);
break;
case ALREADY_EVALUATING:
break;
default :
throw new IllegalStateException(entry + " for " + skyKey+ " in unknown state");
}
}
try {
return waitForCompletionAndConstructResult(visitor,skyKeys);
}
  finally {
inflightKeysReceiver.accept(visitor.inflightNodes);
}
}
