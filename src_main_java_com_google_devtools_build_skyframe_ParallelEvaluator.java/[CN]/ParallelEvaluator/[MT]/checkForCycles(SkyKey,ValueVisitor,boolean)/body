{
  int cyclesFound=0;
  List<SkyKey> graphPath=new ArrayList<>();
  Set<SkyKey> pathSet=new HashSet<>();
  Deque<SkyKey> toVisit=new ArrayDeque<>();
  toVisit.push(root);
  while (!toVisit.isEmpty()) {
    SkyKey key=toVisit.pop();
    NodeEntry entry;
    if (key == CHILDREN_FINISHED) {
      key=graphPath.remove(graphPath.size() - 1);
      entry=Preconditions.checkNotNull(graph.get(key),key);
      pathSet.remove(key);
      if (entry.isDone()) {
        continue;
      }
      if (!keepGoing) {
        continue;
      }
      if (cyclesFound < MAX_CYCLES) {
        Preconditions.checkState(entry.isReady(),"%s not ready. ValueEntry: %s",key,entry);
      }
 else       if (!entry.isReady()) {
        removeIncompleteChildrenForCycle(key,entry,Iterables.concat(entry.getTemporaryDirectDeps()));
      }
      maybeMarkRebuilding(entry);
      GroupedList<SkyKey> directDeps=entry.getTemporaryDirectDeps();
      List<ErrorInfo> errorDeps=getChildrenErrorsForCycle(Iterables.concat(directDeps));
      Preconditions.checkState(!errorDeps.isEmpty(),"Value %s was not successfully evaluated, but had no child errors. ValueEntry: %s",key,entry);
      SkyFunctionEnvironment env=new SkyFunctionEnvironment(key,directDeps,entry.getAllRemainingDirtyDirectDeps(),visitor);
      env.setError(ErrorInfo.fromChildErrors(key,errorDeps),false);
      env.commit(false);
    }
 else {
      entry=graph.get(key);
    }
    Preconditions.checkNotNull(entry,key);
    if (entry.isDone()) {
      continue;
    }
    if (cyclesFound == MAX_CYCLES) {
      continue;
    }
    if (pathSet.contains(key)) {
      int cycleStart=graphPath.indexOf(key);
      cyclesFound++;
      Iterable<SkyKey> cycle=graphPath.subList(cycleStart,graphPath.size());
      if (entry.isDirty() && entry.getDirtyState() == NodeEntry.DirtyState.CHECK_DEPENDENCIES) {
        entry.signalDep();
        maybeMarkRebuilding(entry);
      }
      if (keepGoing) {
        SkyKey cycleChild=selectCycleChild(key,graphPath,cycleStart);
        removeDescendantsOfCycleValue(key,entry,cycleChild,toVisit,graphPath.size() - cycleStart);
        ValueWithMetadata dummyValue=ValueWithMetadata.wrapWithMetadata(new SkyValue(){
        }
);
        SkyFunctionEnvironment env=new SkyFunctionEnvironment(key,entry.getTemporaryDirectDeps(),ImmutableMap.of(cycleChild,dummyValue),entry.getAllRemainingDirtyDirectDeps(),visitor);
        List<ErrorInfo> allErrors=getChildrenErrors(Iterables.concat(entry.getTemporaryDirectDeps()),cycleChild);
        CycleInfo cycleInfo=new CycleInfo(cycle);
        allErrors.add(ErrorInfo.fromCycle(cycleInfo));
        env.setError(ErrorInfo.fromChildErrors(key,allErrors),false);
        env.commit(false);
        continue;
      }
 else {
        Preconditions.checkState(graphPath.get(0).equals(root),"%s not reached from %s. ValueEntry: %s",key,root,entry);
        return ErrorInfo.fromCycle(new CycleInfo(graphPath.subList(0,cycleStart),cycle));
      }
    }
    Iterable<SkyKey> children=Iterables.concat(entry.getTemporaryDirectDeps());
    if (Iterables.isEmpty(children)) {
      continue;
    }
    graph.getBatch(children);
    toVisit.push(CHILDREN_FINISHED);
    graphPath.add(key);
    pathSet.add(key);
    for (    SkyKey nextValue : children) {
      toVisit.push(nextValue);
    }
  }
  return keepGoing ? getAndCheckDone(root).getErrorInfo() : null;
}
