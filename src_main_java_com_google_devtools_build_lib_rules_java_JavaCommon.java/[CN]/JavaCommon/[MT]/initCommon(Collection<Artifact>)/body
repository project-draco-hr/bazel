{
  Preconditions.checkState(javacOpts != null);
  sources=ruleContext.getPrerequisiteArtifacts("srcs",Mode.TARGET).list();
  activePlugins=collectPlugins();
  JavaTargetAttributes.Builder javaTargetAttributes=new JavaTargetAttributes.Builder(semantics);
  javaCompilationHelper=new JavaCompilationHelper(ruleContext,semantics,javacOpts,javaTargetAttributes);
  processSrcs(javaCompilationHelper,javaTargetAttributes);
  javaTargetAttributes.addSourceArtifacts(extraSrcs);
  processRuntimeDeps(javaTargetAttributes);
  semantics.commonDependencyProcessing(ruleContext,javaTargetAttributes,targetsTreatedAsDeps(ClasspathType.COMPILE_ONLY));
  if (!ruleContext.getFragment(JavaConfiguration.class).allowPrecompiledJarsInSrcs() && javaTargetAttributes.hasJarFiles()) {
    ruleContext.attributeError("srcs","precompiled jars are not allowed as sources; use java_import instead?");
  }
  if ((javaTargetAttributes.hasSourceFiles() || javaTargetAttributes.hasSourceJars()) && javaTargetAttributes.hasJarFiles()) {
    ruleContext.attributeWarning("srcs","cannot use both Java sources - source " + "jars or source files - and precompiled jars");
  }
  if (disallowDepsWithoutSrcs(ruleContext.getRule().getRuleClass()) && ruleContext.attributes().get("srcs",BuildType.LABEL_LIST).isEmpty() && ruleContext.getRule().isAttributeValueExplicitlySpecified("deps")) {
    ruleContext.attributeError("deps","deps not allowed without srcs; move to runtime_deps?");
  }
  for (  Artifact resource : semantics.collectResources(ruleContext)) {
    javaTargetAttributes.addResource(JavaHelper.getJavaResourcePath(semantics,ruleContext,resource),resource);
  }
  addPlugins(javaTargetAttributes);
  javaTargetAttributes.setRuleKind(ruleContext.getRule().getRuleClass());
  javaTargetAttributes.setTargetLabel(ruleContext.getLabel());
  return javaTargetAttributes;
}
