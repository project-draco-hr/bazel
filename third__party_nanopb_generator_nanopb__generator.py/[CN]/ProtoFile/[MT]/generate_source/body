def generate_source(self, headername, options):
    u'Generate content for a source file.'
    yield u'/* Automatically generated nanopb constant definitions */\n'
    if options.notimestamp:
        yield (u'/* Generated by %s */\n\n' % nanopb_version)
    else:
        yield (u'/* Generated by %s at %s. */\n\n' % (nanopb_version, time.asctime()))
    yield (options.genformat % headername)
    yield u'\n'
    yield u'#if PB_PROTO_HEADER_VERSION != 30\n'
    yield u'#error Regenerate this file with the current version of nanopb generator.\n'
    yield u'#endif\n'
    yield u'\n'
    for msg in self.messages:
        yield msg.default_decl(False)
    yield u'\n\n'
    for msg in self.messages:
        yield (msg.fields_definition() + u'\n\n')
    for ext in self.extensions:
        yield (ext.extension_def() + u'\n')
    if self.messages:
        largest_msg = max(self.messages, key=(lambda m: m.count_required_fields()))
        largest_count = largest_msg.count_required_fields()
        if (largest_count > 64):
            yield u'\n/* Check that missing required fields will be properly detected */\n'
            yield (u'#if PB_MAX_REQUIRED_FIELDS < %d\n' % largest_count)
            yield (u'#error Properly detecting missing required fields in %s requires \\\n' % largest_msg.name)
            yield (u'       setting PB_MAX_REQUIRED_FIELDS to %d or more.\n' % largest_count)
            yield u'#endif\n'
    max_field = FieldMaxSize()
    checks_msgnames = []
    for msg in self.messages:
        checks_msgnames.append(msg.name)
        for field in msg.fields:
            max_field.extend(field.largest_field_value())
    worst = max_field.worst
    worst_field = max_field.worst_field
    checks = max_field.checks
    if ((worst > 255) or checks):
        yield u'\n/* Check that field information fits in pb_field_t */\n'
        if ((worst > 65535) or checks):
            yield u'#if !defined(PB_FIELD_32BIT)\n'
            if (worst > 65535):
                yield (u'#error Field descriptor for %s is too large. Define PB_FIELD_32BIT to fix this.\n' % worst_field)
            else:
                assertion = u' && '.join(((str(c) + u' < 65536') for c in checks))
                msgs = u'_'.join((str(n) for n in checks_msgnames))
                yield u'/* If you get an error here, it means that you need to define PB_FIELD_32BIT\n'
                yield u' * compile-time option. You can do that in pb.h or on compiler command line.\n'
                yield u' * \n'
                yield u' * The reason you need to do this is that some of your messages contain tag\n'
                yield u' * numbers or field sizes that are larger than what can fit in 8 or 16 bit\n'
                yield u' * field descriptors.\n'
                yield u' */\n'
                yield (u'PB_STATIC_ASSERT((%s), YOU_MUST_DEFINE_PB_FIELD_32BIT_FOR_MESSAGES_%s)\n' % (assertion, msgs))
            yield u'#endif\n\n'
        if (worst < 65536):
            yield u'#if !defined(PB_FIELD_16BIT) && !defined(PB_FIELD_32BIT)\n'
            if (worst > 255):
                yield (u'#error Field descriptor for %s is too large. Define PB_FIELD_16BIT to fix this.\n' % worst_field)
            else:
                assertion = u' && '.join(((str(c) + u' < 256') for c in checks))
                msgs = u'_'.join((str(n) for n in checks_msgnames))
                yield u'/* If you get an error here, it means that you need to define PB_FIELD_16BIT\n'
                yield u' * compile-time option. You can do that in pb.h or on compiler command line.\n'
                yield u' * \n'
                yield u' * The reason you need to do this is that some of your messages contain tag\n'
                yield u' * numbers or field sizes that are larger than what can fit in the default\n'
                yield u' * 8 bit descriptors.\n'
                yield u' */\n'
                yield (u'PB_STATIC_ASSERT((%s), YOU_MUST_DEFINE_PB_FIELD_16BIT_FOR_MESSAGES_%s)\n' % (assertion, msgs))
            yield u'#endif\n\n'
    has_double = False
    for msg in self.messages:
        for field in msg.fields:
            if (field.ctype == u'double'):
                has_double = True
    if has_double:
        yield u'\n'
        yield u'/* On some platforms (such as AVR), double is really float.\n'
        yield u' * These are not directly supported by nanopb, but see example_avr_double.\n'
        yield u' * To get rid of this error, remove any double fields from your .proto.\n'
        yield u' */\n'
        yield u'PB_STATIC_ASSERT(sizeof(double) == 8, DOUBLE_MUST_BE_8_BYTES)\n'
    yield u'\n'
