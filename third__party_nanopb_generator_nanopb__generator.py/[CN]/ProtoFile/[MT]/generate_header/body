def generate_header(self, includes, headername, options):
    u'Generate content for a header file.\n        Generates strings, which should be concatenated and stored to file.\n        '
    yield u'/* Automatically generated nanopb header */\n'
    if options.notimestamp:
        yield (u'/* Generated by %s */\n\n' % nanopb_version)
    else:
        yield (u'/* Generated by %s at %s. */\n\n' % (nanopb_version, time.asctime()))
    symbol = make_identifier(headername)
    yield (u'#ifndef PB_%s_INCLUDED\n' % symbol)
    yield (u'#define PB_%s_INCLUDED\n' % symbol)
    try:
        yield (options.libformat % u'pb.h')
    except TypeError:
        yield options.libformat
    yield u'\n'
    for incfile in includes:
        noext = os.path.splitext(incfile)[0]
        yield (options.genformat % ((noext + options.extension) + u'.h'))
        yield u'\n'
    yield u'#if PB_PROTO_HEADER_VERSION != 30\n'
    yield u'#error Regenerate this file with the current version of nanopb generator.\n'
    yield u'#endif\n'
    yield u'\n'
    yield u'#ifdef __cplusplus\n'
    yield u'extern "C" {\n'
    yield u'#endif\n\n'
    if self.enums:
        yield u'/* Enum definitions */\n'
        for enum in self.enums:
            yield (str(enum) + u'\n\n')
    if self.messages:
        yield u'/* Struct definitions */\n'
        for msg in sort_dependencies(self.messages):
            yield msg.types()
            yield (str(msg) + u'\n\n')
    if self.extensions:
        yield u'/* Extensions */\n'
        for extension in self.extensions:
            yield extension.extension_decl()
        yield u'\n'
    if self.messages:
        yield u'/* Default values for struct fields */\n'
        for msg in self.messages:
            yield msg.default_decl(True)
        yield u'\n'
        yield u'/* Initializer values for message structs */\n'
        for msg in self.messages:
            identifier = (u'%s_init_default' % msg.name)
            yield (u'#define %-40s %s\n' % (identifier, msg.get_initializer(False)))
        for msg in self.messages:
            identifier = (u'%s_init_zero' % msg.name)
            yield (u'#define %-40s %s\n' % (identifier, msg.get_initializer(True)))
        yield u'\n'
        yield u'/* Field tags (for use in manual encoding/decoding) */\n'
        for msg in sort_dependencies(self.messages):
            for field in msg.fields:
                yield field.tags()
        for extension in self.extensions:
            yield extension.tags()
        yield u'\n'
        yield u'/* Struct field encoding specification for nanopb */\n'
        for msg in self.messages:
            yield (msg.fields_declaration() + u'\n')
        yield u'\n'
        yield u'/* Maximum encoded size of messages (where known) */\n'
        for msg in self.messages:
            msize = msg.encoded_size(self.dependencies)
            if (msize is not None):
                identifier = (u'%s_size' % msg.name)
                yield (u'#define %-40s %s\n' % (identifier, msize))
        yield u'\n'
        yield u'/* Message IDs (where set with "msgid" option) */\n'
        yield u'#ifdef PB_MSGID\n'
        for msg in self.messages:
            if hasattr(msg, u'msgid'):
                yield (u'#define PB_MSG_%d %s\n' % (msg.msgid, msg.name))
        yield u'\n'
        symbol = make_identifier(headername.split(u'.')[0])
        yield (u'#define %s_MESSAGES \\\n' % symbol)
        for msg in self.messages:
            m = u'-1'
            msize = msg.encoded_size(self.dependencies)
            if (msize is not None):
                m = msize
            if hasattr(msg, u'msgid'):
                yield (u'\tPB_MSG(%d,%s,%s) \\\n' % (msg.msgid, m, msg.name))
        yield u'\n'
        for msg in self.messages:
            if hasattr(msg, u'msgid'):
                yield (u'#define %s_msgid %d\n' % (msg.name, msg.msgid))
        yield u'\n'
        yield u'#endif\n\n'
    yield u'#ifdef __cplusplus\n'
    yield u'} /* extern "C" */\n'
    yield u'#endif\n'
    yield u'\n#endif\n'
