{
  SkyKey errorKey=GraphTester.toSkyKey("error");
  SkyKey invalidatedKey=GraphTester.toSkyKey("invalidated-leaf");
  SkyKey changedKey=GraphTester.toSkyKey("changed-leaf");
  tester.set(invalidatedKey,new StringValue("invalidated-leaf-value"));
  tester.set(changedKey,new StringValue("changed-leaf-value"));
  final SkyKey cachedParentKey=GraphTester.toSkyKey("A-cached-parent");
  final SkyKey uncachedParentKey=GraphTester.toSkyKey("B-uncached-parent");
  tester.getOrCreate(errorKey).addDependency(invalidatedKey).setHasError(true);
  tester.getOrCreate(cachedParentKey).addDependency(errorKey).setComputedValue(CONCATENATE);
  tester.getOrCreate(uncachedParentKey).addDependency(changedKey).addDependency(errorKey).setComputedValue(CONCATENATE);
  final AtomicBoolean synchronizeThreads=new AtomicBoolean(false);
  final CountDownLatch shutdownAwaiterStarted=new CountDownLatch(1);
  final AtomicReference<Pair<SkyKey,? extends Exception>> unexpectedException=new AtomicReference<>();
  setGraphForTesting(new DeterministicInMemoryGraph(new Listener(){
    private final CountDownLatch cachedSignaled=new CountDownLatch(1);
    @Override public void accept(    SkyKey key,    EventType type,    Order order,    Object context){
      if (!synchronizeThreads.get() || order != Order.BEFORE || type != EventType.SIGNAL) {
        return;
      }
      TrackingAwaiter.INSTANCE.awaitLatchAndTrackExceptions(shutdownAwaiterStarted,"shutdown awaiter not started");
      if (key.equals(uncachedParentKey)) {
        try {
          if (!cachedSignaled.await(TestUtils.WAIT_TIMEOUT_SECONDS,TimeUnit.SECONDS)) {
            Thread currentThread=Thread.currentThread();
            unexpectedException.set(Pair.of(key,new Exception("no interruption or signaling in time for " + (currentThread.isInterrupted() ? "" : "un") + "interrupted "+ currentThread+ " with hash "+ System.identityHashCode(currentThread)+ " at "+ System.currentTimeMillis())));
            return;
          }
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      }
 else       if (key.equals(cachedParentKey)) {
        cachedSignaled.countDown();
        try {
          Thread.sleep(TestUtils.WAIT_TIMEOUT_MILLISECONDS);
          Thread currentThread=Thread.currentThread();
          unexpectedException.set(Pair.of(key,new Exception("no interruption in time for " + (currentThread.isInterrupted() ? "" : "un") + "interrupted "+ currentThread+ " with hash "+ System.identityHashCode(currentThread)+ " at "+ System.currentTimeMillis())));
          return;
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      }
    }
  }
));
  tester.eval(true,cachedParentKey,uncachedParentKey);
  tester.getOrCreate(invalidatedKey,true);
  tester.set(changedKey,new StringValue("new value"));
  tester.invalidate();
  synchronizeThreads.set(true);
  SkyKey waitForShutdownKey=GraphTester.skyKey("wait-for-shutdown");
  tester.getOrCreate(waitForShutdownKey).setBuilder(new SkyFunction(){
    @Override public SkyValue compute(    SkyKey skyKey,    Environment env) throws InterruptedException {
      shutdownAwaiterStarted.countDown();
      TrackingAwaiter.INSTANCE.awaitLatchAndTrackExceptions(((ParallelEvaluator.SkyFunctionEnvironment)env).getExceptionLatchForTesting(),"exception not thrown");
      synchronizeThreads.set(false);
      throw new InterruptedException();
    }
    @Nullable @Override public String extractTag(    SkyKey skyKey){
      return null;
    }
  }
);
  EvaluationResult<StringValue> result=tester.eval(false,cachedParentKey,uncachedParentKey,waitForShutdownKey);
  assertWithMessage(result.toString()).that(result.hasError()).isTrue();
  Pair<SkyKey,? extends Exception> unexpected=unexpectedException.get();
  if (unexpected != null) {
    throw new AssertionError(unexpected.first + ", " + unexpected.second+ ", "+ Arrays.toString(unexpected.second.getStackTrace()));
  }
  tester.getOrCreate(invalidatedKey,true);
  tester.invalidate();
  result=tester.eval(false,cachedParentKey,uncachedParentKey);
  assertWithMessage(result.toString()).that(result.hasError()).isTrue();
}
