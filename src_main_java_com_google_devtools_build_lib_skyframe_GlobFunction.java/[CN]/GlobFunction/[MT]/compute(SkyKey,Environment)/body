{
  GlobDescriptor glob=(GlobDescriptor)skyKey.argument();
  PathFragment globSubdir=glob.getSubdir();
  if (!globSubdir.equals(PathFragment.EMPTY_FRAGMENT)) {
    PackageLookupValue globSubdirPkgLookupValue=(PackageLookupValue)env.getValue(PackageLookupValue.key(PackageIdentifier.create(glob.getPackageId().getRepository(),glob.getPackageId().getPackageFragment().getRelative(globSubdir))));
    if (globSubdirPkgLookupValue == null) {
      return null;
    }
    if (globSubdirPkgLookupValue.packageExists()) {
      return GlobValue.EMPTY;
    }
  }
  String pattern=glob.getPattern();
  int slashPos=pattern.indexOf('/');
  String patternHead;
  String patternTail;
  if (slashPos == -1) {
    patternHead=pattern;
    patternTail=null;
  }
 else {
    patternHead=pattern.substring(0,slashPos);
    patternTail=pattern.substring(slashPos + 1);
  }
  NestedSetBuilder<PathFragment> matches=NestedSetBuilder.stableOrder();
  boolean globMatchesBareFile=patternTail == null;
  if ("**".equals(patternHead)) {
    if (globMatchesBareFile) {
      if (!glob.excludeDirs() && !globSubdir.equals(PathFragment.EMPTY_FRAGMENT)) {
        matches.add(globSubdir);
      }
    }
 else {
      SkyKey globKey=GlobValue.internalKey(glob.getPackageId(),glob.getPackageRoot(),globSubdir,patternTail,glob.excludeDirs());
      GlobValue globValue=(GlobValue)env.getValue(globKey);
      if (globValue == null) {
        return null;
      }
      matches.addTransitive(globValue.getMatches());
    }
  }
  PathFragment dirPathFragment=glob.getPackageId().getPackageFragment().getRelative(globSubdir);
  RootedPath dirRootedPath=RootedPath.toRootedPath(glob.getPackageRoot(),dirPathFragment);
  if (alwaysUseDirListing || containsGlobs(patternHead)) {
    String subdirPattern="**".equals(patternHead) ? glob.getPattern() : patternTail;
    DirectoryListingValue listingValue=(DirectoryListingValue)env.getValue(DirectoryListingValue.key(dirRootedPath));
    if (listingValue == null) {
      return null;
    }
    int direntsSize=listingValue.getDirents().size();
    Map<Dirent,SkyKey> symlinkFileMap=Maps.newHashMapWithExpectedSize(direntsSize);
    Map<Dirent,SkyKey> firstPassSubdirMap=Maps.newHashMapWithExpectedSize(direntsSize);
    for (    Dirent dirent : listingValue.getDirents()) {
      Type direntType=dirent.getType();
      String fileName=dirent.getName();
      if (!UnixGlob.matches(patternHead,fileName,regexPatternCache)) {
        continue;
      }
      if (direntType == Dirent.Type.SYMLINK) {
        symlinkFileMap.put(dirent,FileValue.key(RootedPath.toRootedPath(glob.getPackageRoot(),dirPathFragment.getRelative(fileName))));
        continue;
      }
      if (direntType == Dirent.Type.DIRECTORY) {
        SkyKey keyToRequest=getSkyKeyForSubdir(fileName,glob,subdirPattern);
        if (keyToRequest != null) {
          firstPassSubdirMap.put(dirent,keyToRequest);
        }
      }
 else       if (globMatchesBareFile) {
        matches.add(glob.getSubdir().getRelative(fileName));
      }
    }
    Map<SkyKey,SkyValue> firstPassAndSymlinksResult=env.getValues(Iterables.concat(firstPassSubdirMap.values(),symlinkFileMap.values()));
    if (env.valuesMissing()) {
      return null;
    }
    Map<Dirent,SkyKey> symlinkSubdirMap=Maps.newHashMapWithExpectedSize(symlinkFileMap.size());
    for (    Map.Entry<Dirent,SkyKey> direntAndKey : symlinkFileMap.entrySet()) {
      Dirent dirent=direntAndKey.getKey();
      String fileName=dirent.getName();
      Preconditions.checkState(dirent.getType() == Dirent.Type.SYMLINK,direntAndKey);
      FileValue symlinkFileValue=Preconditions.checkNotNull((FileValue)firstPassAndSymlinksResult.get(direntAndKey.getValue()),direntAndKey);
      if (!symlinkFileValue.isSymlink()) {
        throw new GlobFunctionException(new InconsistentFilesystemException("readdir and stat disagree about whether " + ((RootedPath)direntAndKey.getValue().argument()).asPath() + " is a symlink."),Transience.TRANSIENT);
      }
      if (!symlinkFileValue.exists()) {
        continue;
      }
      if (symlinkFileValue.isDirectory()) {
        SkyKey keyToRequest=getSkyKeyForSubdir(fileName,glob,subdirPattern);
        if (keyToRequest != null) {
          symlinkSubdirMap.put(dirent,keyToRequest);
        }
      }
 else       if (globMatchesBareFile) {
        matches.add(glob.getSubdir().getRelative(fileName));
      }
    }
    Map<SkyKey,SkyValue> secondResult=env.getValues(symlinkSubdirMap.values());
    if (env.valuesMissing()) {
      return null;
    }
    for (    Map.Entry<Dirent,SkyKey> direntAndKey : Iterables.concat(firstPassSubdirMap.entrySet(),symlinkSubdirMap.entrySet())) {
      Dirent dirent=direntAndKey.getKey();
      String fileName=dirent.getName();
      SkyKey key=direntAndKey.getValue();
      SkyValue valueRequested=symlinkSubdirMap.containsKey(dirent) ? secondResult.get(key) : firstPassAndSymlinksResult.get(key);
      Preconditions.checkNotNull(valueRequested,direntAndKey);
      addSubdirMatchesFromSkyValue(fileName,glob,matches,valueRequested);
    }
  }
 else {
    String fileName=patternHead;
    RootedPath fileRootedPath=RootedPath.toRootedPath(glob.getPackageRoot(),dirPathFragment.getRelative(fileName));
    FileValue fileValue=(FileValue)env.getValue(FileValue.key(fileRootedPath));
    if (fileValue == null) {
      return null;
    }
    if (fileValue.exists()) {
      if (fileValue.isDirectory()) {
        SkyKey keyToRequest=getSkyKeyForSubdir(fileName,glob,patternTail);
        if (keyToRequest != null) {
          SkyValue valueRequested=env.getValue(keyToRequest);
          if (env.valuesMissing()) {
            return null;
          }
          addSubdirMatchesFromSkyValue(fileName,glob,matches,valueRequested);
        }
      }
 else       if (globMatchesBareFile) {
        matches.add(glob.getSubdir().getRelative(fileName));
      }
    }
  }
  Preconditions.checkState(!env.valuesMissing(),skyKey);
  NestedSet<PathFragment> matchesBuilt=matches.build();
  if (matchesBuilt.isEmpty()) {
    return GlobValue.EMPTY;
  }
  return new GlobValue(matchesBuilt);
}
