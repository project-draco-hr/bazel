{
  GitRepositoryDescriptor descriptor=(GitRepositoryDescriptor)skyKey.argument();
  Git git=null;
  try {
    if (descriptor.directory.exists()) {
      if (isUpToDate(descriptor)) {
        return new HttpDownloadValue(descriptor.directory);
      }
      try {
        FileSystemUtils.deleteTree(descriptor.directory);
      }
 catch (      IOException e) {
        throw new RepositoryFunctionException(e,Transience.TRANSIENT);
      }
    }
    git=Git.cloneRepository().setURI(descriptor.remote).setDirectory(descriptor.directory.getPathFile()).setCloneSubmodules(false).setNoCheckout(true).setProgressMonitor(new GitProgressMonitor("Cloning " + descriptor.remote,reporter)).call();
    git.checkout().setCreateBranch(true).setName("bazel-checkout").setStartPoint(descriptor.checkout).call();
    if (descriptor.initSubmodules && !git.submoduleInit().call().isEmpty()) {
      git.submoduleUpdate().setProgressMonitor(new GitProgressMonitor("Cloning submodules for " + descriptor.remote,reporter)).call();
    }
  }
 catch (  InvalidRemoteException e) {
    throw new RepositoryFunctionException(new IOException("Invalid Git repository URI: " + e.getMessage()),Transience.PERSISTENT);
  }
catch (  RefNotFoundException|InvalidRefNameException e) {
    throw new RepositoryFunctionException(new IOException("Invalid branch, tag, or commit: " + e.getMessage()),Transience.PERSISTENT);
  }
catch (  GitAPIException e) {
    throw new RepositoryFunctionException(new IOException(e.getMessage()),Transience.TRANSIENT);
  }
 finally {
    if (git != null) {
      git.close();
    }
  }
  return new HttpDownloadValue(descriptor.directory);
}
