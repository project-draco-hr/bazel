{
  RootedPath rootedPath=recursivePkgKey.getRootedPath();
  BlacklistedPackagePrefixesValue blacklist=(BlacklistedPackagePrefixesValue)env.getValue(BlacklistedPackagePrefixesValue.key());
  if (blacklist == null) {
    return null;
  }
  Set<PathFragment> excludedPaths=Sets.union(recursivePkgKey.getExcludedPaths(),blacklist.getPatterns());
  Path root=rootedPath.getRoot();
  PathFragment rootRelativePath=rootedPath.getRelativePath();
  SkyKey fileKey=FileValue.key(rootedPath);
  FileValue fileValue;
  try {
    fileValue=(FileValue)env.getValueOrThrow(fileKey,InconsistentFilesystemException.class,FileSymlinkException.class,IOException.class);
  }
 catch (  InconsistentFilesystemException|FileSymlinkException|IOException e) {
    return reportErrorAndReturn("Failed to get information about path",e,rootRelativePath,env.getListener());
  }
  if (fileValue == null) {
    return null;
  }
  if (!fileValue.isDirectory()) {
    return getEmptyReturn();
  }
  PackageIdentifier packageId=PackageIdentifier.create(recursivePkgKey.getRepository(),rootRelativePath);
  SkyKey pkgLookupKey=PackageLookupValue.key(packageId);
  SkyKey dirListingKey=DirectoryListingValue.key(rootedPath);
  Map<SkyKey,ValueOrException4<NoSuchPackageException,InconsistentFilesystemException,FileSymlinkException,IOException>> pkgLookupAndDirectoryListingDeps=env.getValuesOrThrow(ImmutableList.of(pkgLookupKey,dirListingKey),NoSuchPackageException.class,InconsistentFilesystemException.class,FileSymlinkException.class,IOException.class);
  if (env.valuesMissing()) {
    return null;
  }
  PackageLookupValue pkgLookupValue;
  try {
    pkgLookupValue=(PackageLookupValue)Preconditions.checkNotNull(pkgLookupAndDirectoryListingDeps.get(pkgLookupKey).get(),"%s %s",recursivePkgKey,pkgLookupKey);
  }
 catch (  NoSuchPackageException|InconsistentFilesystemException e) {
    return reportErrorAndReturn("Failed to load package",e,rootRelativePath,env.getListener());
  }
catch (  IOException|FileSymlinkException e) {
    throw new IllegalStateException(e);
  }
  TVisitor visitor=getInitialVisitor();
  if (pkgLookupValue.packageExists()) {
    if (pkgLookupValue.getRoot().equals(root)) {
      Package pkg=null;
      try {
        PackageValue pkgValue=(PackageValue)env.getValueOrThrow(PackageValue.key(packageId),NoSuchPackageException.class);
        if (pkgValue == null) {
          return null;
        }
        pkg=pkgValue.getPackage();
        if (pkg.containsErrors()) {
          env.getListener().handle(Event.error("package contains errors: " + rootRelativePath.getPathString()));
        }
      }
 catch (      NoSuchPackageException e) {
        env.getListener().handle(Event.error("package contains errors: " + rootRelativePath.getPathString()));
      }
      if (pkg != null) {
        visitor.visitPackageValue(pkg,env);
        if (env.valuesMissing()) {
          return null;
        }
      }
    }
  }
  DirectoryListingValue dirListingValue;
  try {
    dirListingValue=(DirectoryListingValue)Preconditions.checkNotNull(pkgLookupAndDirectoryListingDeps.get(dirListingKey).get(),"%s %s",recursivePkgKey,dirListingKey);
  }
 catch (  InconsistentFilesystemException|IOException e) {
    return reportErrorAndReturn("Failed to list directory contents",e,rootRelativePath,env.getListener());
  }
catch (  FileSymlinkException e) {
    throw new IllegalStateException("Symlink cycle found after not being found for \"" + rootedPath + "\"");
  }
catch (  NoSuchPackageException e) {
    throw new IllegalStateException(e);
  }
  List<SkyKey> childDeps=Lists.newArrayList();
  boolean followSymlinks=shouldFollowSymlinksWhenTraversing(dirListingValue.getDirents());
  for (  Dirent dirent : dirListingValue.getDirents()) {
    Type type=dirent.getType();
    if (type != Type.DIRECTORY && (type != Type.SYMLINK || (type == Type.SYMLINK && !followSymlinks))) {
      continue;
    }
    String basename=dirent.getName();
    if (rootRelativePath.equals(PathFragment.EMPTY_FRAGMENT) && PathPackageLocator.DEFAULT_TOP_LEVEL_EXCLUDES.contains(basename)) {
      continue;
    }
    PathFragment subdirectory=rootRelativePath.getRelative(basename);
    if (excludedPaths.contains(subdirectory)) {
      continue;
    }
    ImmutableSet<PathFragment> excludedSubdirectoriesBeneathThisSubdirectory=PathFragment.filterPathsStartingWith(excludedPaths,subdirectory);
    RootedPath subdirectoryRootedPath=RootedPath.toRootedPath(root,subdirectory);
    childDeps.add(getSkyKeyForSubdirectory(recursivePkgKey.getRepository(),subdirectoryRootedPath,excludedSubdirectoriesBeneathThisSubdirectory));
  }
  Map<SkyKey,SkyValue> subdirectorySkyValues=env.getValues(childDeps);
  if (env.valuesMissing()) {
    return null;
  }
  return aggregateWithSubdirectorySkyValues(visitor,subdirectorySkyValues);
}
